<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blogs on GuangzhengLi</title><link>https://guangzhengli.com/blog/</link><description>Recent content in Blogs on GuangzhengLi</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>iguangzhengli@gmail.com (Guangzheng Li)</managingEditor><webMaster>iguangzhengli@gmail.com (Guangzheng Li)</webMaster><copyright>2023 GuangzhengLi All rights reserved</copyright><lastBuildDate>Mon, 31 Jul 2023 20:10:00 +0800</lastBuildDate><atom:link href="https://guangzhengli.com/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>GPT 应用开发和思考</title><link>https://guangzhengli.com/blog/zh/gpt-embeddings/</link><pubDate>Mon, 31 Jul 2023 20:10:00 +0800</pubDate><author>iguangzhengli@gmail.com (Guangzheng Li)</author><guid>https://guangzhengli.com/blog/zh/gpt-embeddings/</guid><description>&lt;p>在过去几个月的时间中，我们似乎正处于人工智能的革命中。除了大多数人了解的 OpenAI ChatGPT 之外，许多非常新颖、有趣、实用的 AI 应用也是层出不穷，并且在使用这些应用时时，笔者也确确实实的感受到了生产力的提高。&lt;/p>
&lt;p>但是关于 GPT 应用的开发知识和路线，目前似乎还没有太多的资料，所以笔者决定将自己的一些经验和思考整理成一个系列，希望能够帮助到大家。&lt;/p>
&lt;p>本篇文章主要介绍的是 GPT 相关应用的开发思考，在今年 4 月份的时候，笔者因为开发 &lt;a href="https://github.com/guangzhengli/ChatFiles">ChatFiles&lt;/a> 这个开源项目，从而学习了 GPT 相关的技术知识，但是由于笔者的时间精力有限，所以一直没有机会将这些知识整理成一篇文章，直到最近笔者又因为有了新的想法，开源了 &lt;a href="https://github.com/guangzhengli/vectorhub">VectorHub&lt;/a> 这个同样基于 GPT Prompt 和 Embeddings 技术的项目，进而对 GPT 和 Embeddings 等技术知识有了更深入的了解，所以就有了这一篇分享。&lt;/p>
&lt;h2 id="从-prompt-开始">从 Prompt 开始&lt;/h2>
&lt;p>AI 应用开发在过去一段时间内吸引了众多开发者入场，除了大家所熟知的 ChatGPT 之外，还涌现了大量有实际价值的 AI 应用，例如基于 AI 的翻译类的应用如 &lt;a href="https://github.com/openai-translator/openai-translator">openai-translator&lt;/a>、&lt;a href="https://immersivetranslate.com/">immersivetranslate&lt;/a>，写作类的应用如 &lt;a href="https://www.notion.so/product/ai">Notion AI&lt;/a>，编程辅助类的应用如 &lt;a href="https://github.com/features/copilot">GitHub Copilot&lt;/a> 和 &lt;a href="https://docs.github.com/en/copilot/github-copilot-chat/using-github-copilot-chat?tool=vscode">GitHub Copilot Chat&lt;/a>。&lt;/p>
&lt;p>这些应用有些是优化了原有的体验，如基于 GPT 的翻译的 &lt;a href="https://github.com/openai-translator/openai-translator">openai-translator&lt;/a>，翻译质量和阅读体验远胜于之前的机器翻译，还有些则是提供了之前无法实现的功能，如 &lt;a href="https://github.com/features/copilot">GitHub Copilot&lt;/a> 的代码补全和生成，还有像 &lt;a href="https://docs.github.com/en/copilot/github-copilot-chat/using-github-copilot-chat?tool=vscode">GitHub Copilot Chat&lt;/a> 提供回答编码相关问题、解释代码、生成单元测试、给错误代码提出修复意见等等功能，这些功能的实现难度在以前是完全无法想象的。&lt;/p>
&lt;p>这些应用在功能上虽然没有相似之处，但是在实现原理中，它们都是主要基于 GPT 的 Prompt(提示)实现。Prompt 指的是提供给模型的文本或指令，可以用来引导模型生成自然语言输出(Completion)。它可以给模型提供上下文信息，对模型的输出结果至关重要。&lt;/p>
&lt;p>我们知道 GPT（Generative Pre-trained Transformer）是一个推理模型，它主要基于预训练和微调两个阶段。&lt;/p>
&lt;p>在预训练阶段会使用一个大规模的语料库进行基础训练，例如使用维基百科、新闻文章、小说等来进行训练。当训练完成后，输入一句话给它，它会基于这句话给出一个概率上的预测，预测后续应该拼接上什么单词，这个拼接的单词是基于它在预训练阶段学习到的知识来进行概率选定的，通过一次次循环的单词预测，最终可以拼接出一段话来。这也是它被称为生成式 AI 的原因。&lt;/p>
&lt;p>这一句话就是我们所说的 Prompt，也是生成式 AI 概率生成的基础。这能解释为什么我们每次输入相同的 Prompt，但是每次得到的结果都会有所不同，因为每次的结果都是基于概率生成的。&lt;/p>
&lt;p>所以我们也就能理解为什么 Prompt 对于 GPT 应用开发的重要性，因为它是除了微调以外，我们能与 GPT 模型唯一的交互方式（当然除此之外还可以通过调整模型的 temperature 和 top_p 两个配置来控制 GPT 更多样化或更具创造性的输出，不过对于输出质量和对下游任务的处理能力并无明显影响）。所以 Prompt 是 GPT 应用开发最核心的部分，也是最需要开发者去思考和优化的部分。&lt;/p>
&lt;p>在预训练完成后，在微调阶段会将 GPT 模型加载到特定的任务上，并使用该任务的数据集对模型进行训练。这样，模型就可以根据任务的要求进行微调，以便更好地理解 Prompt 并生成与任务相关的文本。通过微调，GPT 可以适应不同的任务，如文本分类、情感分析、问答系统等。不过目前微调因为成本昂贵和最终效果并不稳定，对于广大 GPT 开发者来讲，并不是非常好的选择，所以目前大部分的 GPT 应用开发者都是基于 Prompt 来开发应用。&lt;/p>
&lt;h2 id="prompt-学习路线">Prompt 学习路线&lt;/h2>
&lt;p>关于 Prompt 的基础知识，可以先去看看吴恩达老师的 &lt;a href="https://www.deeplearning.ai/short-courses/chatgpt-prompt-engineering-for-developers/">ChatGPT Prompt 工程&lt;/a>。可以通过两个小时不到的视频可以快速的了解 Prompt 的使用方式和它的魅力所在。&lt;/p>
&lt;p>在有了一个初步的了解之后，笔者推荐 &lt;a href="https://www.promptingguide.ai/">Prompt Engineering Guide&lt;/a> 这份文档，该文档包含了大量的 Prompt 基础知识和未来的发展方向，对于 GPT 应用开发者来说，除了学习 Prompt 的基础知识之外，还可以从中获取到一些工程界和学术界对于 Prompt 的发展方向的思考，对于开发 AI 应用来说，这些思考弥足珍贵。&lt;/p>
&lt;p>最后，非常推荐大家去看看 OpenAI 官方的 &lt;a href="https://platform.openai.com/docs/guides/gpt-best-practices">GPT 最佳实践&lt;/a> 这份文档，它是由 OpenAI 官方提供的 GPT 最佳实践指南，里面包含了大量的 Prompt 示例和使用技巧，对于 GPT 应用开发者来说，是一份非常有价值的文档。因为它是 OpenAI 官方通过合作伙伴或者 Hackathon 等不同的方式，在不同的业务领域 GPT 应用开发中总结出来的最佳实践，对于开发者来讲非常有启发价值！下面是对这一份文档的摘录：&lt;/p>
&lt;blockquote class="twitter-tweet">&lt;p lang="zh" dir="ltr">撰写清晰的 Prompt&lt;br>&lt;br>1⃣️：在问题中包含详细的信息，例如以下例子：&lt;br>&lt;br>不好的提问：总结会议记录。&lt;br>优秀的提问：将会议记录总结成一个段落。然后用 Markdown 列表的格式列举一下参与者们各自的要点。最后如果有的话，列出演讲者建议的下一步行动或行动项目。&lt;br>&lt;br>不好的提问：编写代码来计算斐波那契数列。…&lt;/p>&amp;mdash; Guangzheng Li (@iguangzhengli) &lt;a href="https://twitter.com/iguangzhengli/status/1668059021390266369?ref_src=twsrc%5Etfw">June 12, 2023&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;h2 id="prompt-最佳实践">Prompt 最佳实践&lt;/h2>
&lt;p>关于 Prompt 编写的最佳实践，最为推荐的当然是 OpenAI 官方出品的 &lt;a href="https://platform.openai.com/docs/guides/gpt-best-practices">GPT 最佳实践&lt;/a> 这份文档，但对于开发 GPT 应用来讲，笔者还是想结合这份最佳实践和一些自己的经验，给大家分享一些 GPT 开发的实践。&lt;/p>
&lt;h3 id="清晰和详细">清晰和详细&lt;/h3>
&lt;p>现实中大部分开发者在平常使用 GPT 的时候，都是以解决编程问题或者询问问题为主，所以容易带入以往使用 Google 等搜索引擎的经验来使用和开发 GPT。&lt;/p>
&lt;p>例如当你想知道如何用 Python 编写斐波那契数列的时候，如果在以前使用 Google 搜索引擎，你可能会输入 &lt;code>python fibonacci&lt;/code>。因为这样就足够了，Google 是基于倒排索引和 PageRank 算法的，只需要输入关键字，就能得到高质量的网页答案。&lt;/p>
&lt;p>所以只需要这种输入两个字的输入方式是最简单和最高效的，毕竟就算多输入几个字 &lt;code>how to write python fibonacci&lt;/code> ，对于 Google 搜索引擎来讲，输出质量是相差不大的。&lt;/p>
&lt;p>而如果你使用的是 GPT，像 &lt;code>python fibonacci&lt;/code> 这样的输入对于 GPT 来说是非常不友好的，因为它无法清晰的理解你的意图，所以它可能会给出一些不相关的结果（根据不同模型的质量会略有差异）。&lt;/p>
&lt;p>但如果你输入的是 &lt;code>编写一个用 python 函数来高效地计算 fibonacci 数列。评论每一行代码以解释每一部分的作用以及为什么这样写&lt;/code>。这样的输入对于 GPT 来说就非常清晰和详细，它能够清晰的理解你的意图，所以它给出的结果也会更加准确，&lt;strong>在保证输出质量下限的同时，还可以提高输出质量的上限！&lt;/strong>&lt;/p>
&lt;p>这和开发者以往使用 Google 等搜索引擎的经验是完全不同的，也是 GPT 开发者和使用者最容易忽视的地方。笔者在今年很早的时候开发 &lt;a href="https://github.com/guangzhengli/ChatFiles">ChatFiles&lt;/a> 项目时，曾匿名收集过使用者的 Prompt，发现 95% 以上的使用者使用的都是非常简单的 Prompt，简单的甚至看起来有一种一字千金的感觉。&lt;/p>
&lt;p>所以当开发者开发 GPT 应用时，一定要注意 Prompt 的清晰和详细，多试几次，选择一个输出质量稳定和格式相同的 Prompt，这是保证 GPT 应用质量的关键。&lt;/p>
&lt;h3 id="如何处理更加复杂的任务">如何处理更加复杂的任务&lt;/h3>
&lt;p>相信所有开发者面对简单的场景任务，多花费一些时间来调整 Prompt，都能设计好程序的 Prompt 并得到不错的输出质量。但是面对复杂任务时，想要提高 GPT 的输出质量还需要两个非常重要的技巧：&lt;strong>让 GPT 推理而不是回答，和拆分任务进行引导&lt;/strong>。&lt;/p>
&lt;h4 id="推理而不是回答">推理而不是回答&lt;/h4>
&lt;p>推理而不是回答是指在 Prompt 中，要求 GPT 模型不要立即判断正确与否或者立刻给出答案，而是引导模型进行深入思考。可以要求其先列出对问题的各种看法，对任务进行拆分，说明每一步的推理依据，然后再得出最终结论。在 Prompt 中添加逐步推理的要求，能让语言模型投入更多时间逻辑思维，输出结果也将更可靠准确。&lt;/p>
&lt;p>举一个&lt;a href="https://platform.openai.com/docs/guides/gpt-best-practices/tactic-instruct-the-model-to-work-out-its-own-solution-before-rushing-to-a-conclusion">OpenAI 官方的例子&lt;/a>，如果你需要 GPT 回答某一个学生的答案是否正确，Prompt 是 &lt;code>判断学生的解决方案是否正确&lt;/code>的话，面对复杂的计算问题和答案，GPT 有很大的概率会给出错误的答案，因为 GPT 并不会像人一样先进行推理答案再进行回答，而是会立即给出判断。在短暂的判断中，就无法给出正确的答案（就好比人类无法在短时间计算复杂数学一样）。&lt;/p>
&lt;p>所以如果我们的 Prompt 是 &lt;code>首先自己解决问题，然后再将自己的解决方案与学生的解决方案进行比较，并评估学生的解决方案是否正确。在自己完成问题之前，不要确定学生的解决方案是否正确&lt;/code>。在 Prompt 中给出明确的引导和条件，就能够让 GPT 模型花费更多的时间推导答案，从而得到更加准确的结果。&lt;/p>
&lt;h4 id="拆分任务">拆分任务&lt;/h4>
&lt;p>拆分任务进行引导是指将一个复杂的任务拆分成多个子任务，然后分别引导 GPT 模型进行推理，最后将多个子任务的结果进行整合，得到最终的结果。这样做的好处是可以让 GPT 模型更加专注于一个子任务，从而提高输出质量。&lt;/p>
&lt;p>举一个不太恰当的例子，当你需要对一本书籍进行摘要的时候，GPT 直接进行总体的摘要的效果并不好，我们可以使用一系列子任务来摘要每个部分。最后再汇总产生的摘要。&lt;/p>
&lt;p>当然拆分任务也会带来一些新的问题，即当单个任务输出质量有问题时，整体的输出质量也会受其影响。加上目前的 token 费用不菲，拆分任务进行引导也会带来额外的成本。但是无论如何，目前关于如何设计和拆分复杂任务是所有 GPT 应用最需要思考，和维护自身 AI 应用护城河的核心问题，也是目前大模型 AI 框架像 LangChain 等项目的核心设计点，有空可以单独写一篇文章来讨论。&lt;/p>
&lt;h3 id="使用技巧">使用技巧&lt;/h3>
&lt;p>除了上述的一些比较重要的实践之外，还有一些小技巧对于开发应用也是非常有帮助，下面是笔者总结的一些使用技巧：&lt;/p>
&lt;ul>
&lt;li>提供少量示例(Few-Shot Prompting): 给模型一两个期望的输入输出样例，让模型了解我们的要求和期望的输出样式。&lt;/li>
&lt;li>Prompt 中要求结构化输出：以 Json 的方式输出，这样可以方便后续代码程序处理。&lt;/li>
&lt;li>分隔符：使用分隔符像 &lt;code>&amp;quot;&amp;quot;&amp;quot;&lt;/code> 将不同的指令、上下文之间进行隔离，防止系统的 Prompt 和用户输入的 Prompt 混淆冲突。&lt;/li>
&lt;/ul>
&lt;h2 id="gpt-embedding-应用开发">GPT Embedding 应用开发&lt;/h2>
&lt;p>在上面我们主要介绍了基于 Prompt 如何开发 AI 应用，但是有时候我们还会遇到新的问题。例如大模型的训练数据往往是基于几个月前、甚至是几年前的，当我们有一些需求场景是需要 GPT 应用提供最新的数据，例如基于最近的新闻来回答问题，或者根据私有文档来回答问题，这时候大模型本身就没有基于这些材料进行过训练，也就无法解决该类问题。&lt;/p>
&lt;p>这个时候我们可以通过让模型使用参考文本来回答问题，例如我们的 prompt 可以写成:&lt;/p>
&lt;pre tabindex="0">&lt;code>你将会得到一个由三个引号分隔的文档和一个问题。
你的任务是使用提供的文档回答问题，并引用用于回答问题的文本段落。
如果文档中没有包含回答该问题所需的信息，则简单地写下：“信息不足”。
如果提供问题的答案，必须附带引用注释。
使用以下格式引用相关段落（{&amp;#34;citation&amp;#34;: …}）。
&lt;/code>&lt;/pre>&lt;p>这种使用方式可以让 GPT 针对于我们给予它的参考文本进行回答，例如我们想问最新的世界杯冠军是谁，就可以附上最新的世界杯新闻的参考文本，这样 GPT 会先理解整篇新闻，再来问答问题。通过这种方式，就可以解决大模型针对于时效性和特定的下游任务的问题。&lt;/p>
&lt;p>但是这种解决方案会带来另外一个问题，即参考文本长度限制的问题。GPT Prompt 是有大小限制的，像 gpt-3.5-turbo 模型它的限制是 4K tokens(～3000字)，这意味着使用者最多只能输入 3000 字给 GPT 来理解和推理答案。&lt;/p>
&lt;p>那么一旦需要的参考文本大于 3000 字，就无法一次性通过 GPT 得到答案，需要开发者想办法将参考文本拆分成多个部分，然后分别进行 GPT Embeddings 转化为向量存储到向量数据库中。关于向量数据库的更多信息，可以参考我另外一篇博客 &lt;a href="https://guangzhengli.com/blog/zh/vector-database/">向量数据库&lt;/a>，当需要针对于参考文本进行提问时，需要先将问题转化为向量，然后通过向量数据库进行检索，最后再将检索到的向量转化为文本输出。这样就能得到符合 GPT tokens 限制的参考文本，并且这段参考文本是和问题具有关联的。&lt;/p>
&lt;p>我们拿到问题本身和这段具有关联的参考文本，同时提交给 GPT，就能得到我们想要的答案。这个过程就是 GPT Embeddings 应用开发核心，它的核心思想是通过向量检索的方式检索与问题最相关的文本段，从而绕过 GPT tokens 的限制。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/Embedding.png" alt="Embedding">&lt;/p>
&lt;p>整体的开发流程如上图所示：&lt;/p>
&lt;ol>
&lt;li>加载文档，获取目标文本信息。例如 LLM 主流框架 LangChain 中 File Loader 和 Web Loader 的两种文本获取方式。
&lt;ol>
&lt;li>基于文件系统的 File Loader，如加载 PDF 文件、Word 文件等。&lt;/li>
&lt;li>基于网络的 Web Loader，如某个网页，AWS S3 等。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>将目标文本拆分为多个段落，拆分方式主要基于两种。
&lt;ol>
&lt;li>一种是基于文字数量的拆分法，例如 1000 字为一段，这种方式的优点是简单，缺点是可能会将一个段落拆分成多个段落，导致段落的连贯性变差，从而导致最终回答结果可能缺少上下文而降低回答质量。&lt;/li>
&lt;li>另一种是基于标点符号的拆分法，例如以换行为分隔符，这种方式的优点是段落的连贯性好，缺点是每个段落大小不一，可能会导致触发 GPT tokens 的限制。&lt;/li>
&lt;li>最后一种是基于 GPT tokens 限制的拆分法，例如以 2000 tokens 为一组，最终查询时搜索出最相关的两个段落，这样加到一起也才 4000 tokens,就不会触发到 4096 tokens 的限制。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>将拆分的文本块统一存入 &lt;a href="https://guangzhengli.com/blog/zh/vector-database/">向量数据库&lt;/a> 中。&lt;/li>
&lt;li>将用户问题转化为向量，然后通过向量数据库进行检索，得到最相关的文本段落。（需要注意的是，这里的检索并不是传统数据库的模糊匹配或者倒排索引，而是基于语义化的搜索能力，所以检索出的文本才能回答用户问题，详细请看另外一篇博客 [向量数据库](https://guangzhengli.com/blog/zh/vector-database/）&lt;/li>
&lt;li>将检索出来的相关文本信息，用户问题和系统的 prompt 三个组合成一个针对于 Embeddings 场景的 Prompt，例如 Prompt 中明确写到使用参考文本回答问题，而不是 GPT 自己回答。&lt;/li>
&lt;li>GPT 回答最终得到的 Prompt，得到最终的答案。&lt;/li>
&lt;/ol>
&lt;p>如果你对具体的实现代码感兴趣，可以去看看 LangChain 中关于 &lt;a href="https://js.langchain.com/docs/modules/data_connection/">Retrieval 的章节&lt;/a>。&lt;/p>
&lt;p>GPT embeddings 应用能解决某些场景下 GPT 无法回答的问题，这是他最大的优点。无需训练，无需微调，只需要将文本转化为向量再通过检索就能实现，以低成本的方式就能让某些业务场景变成可能。&lt;/p>
&lt;p>但这个方案同样会带来一些新的问题，例如 embeddings 文本拆分和检索的质量将在很大的程度上影响最终的结果，还有查询范围、质量和查询时间该如何均衡，检索出的参考文本无法回答用户问题时该如何处理？这都是开发者在面对业务需求和场景时需要仔细思考的问题。&lt;/p>
&lt;p>如果思考更远一点，在人类过去的时间中，所有的文档都是面向人来编写，对于向量检索来说并不是最佳组织模式，以后是否会存在专门面向 AI 和检索编写的文本？让 AI 更好理解和更好符合数据库检索？不过这些问题需要长期的思考和论证，这里不再扩展。&lt;/p>
&lt;h2 id="gpt-agents-应用开发">GPT Agents 应用开发&lt;/h2>
&lt;p>除了上述的 prompt 和 embeddings 两种方案能解决的业务需求外，GPT 应用开发还有一个非常常见的需求，即如何集成现有系统，或者说是如何集成现有 API。&lt;/p>
&lt;p>因为软件行业已经发展了很多年，很多公司都有自己的系统和 API，这些 API 能够极大的提高 GPT 应用的能力边界。如果 GPT 应用想要在实际生活场景中落地，是不可避免的需要和现有系统进行集成。&lt;/p>
&lt;p>就像如果你想要询问 GPT 一个非常简单的问题，今天北京的天气是什么？看完上面的章节，我们知道 GPT 自己是无法回答这类问题的，如果 GPT 能够自行调用某个天气 API，那么开发起来将非常的方便。&lt;/p>
&lt;p>想要实现 GPT 调用查询天气这个 API 的需求，我们会面临两个问题，一个是让 GPT 应用理解某个 API 的功能，并在它觉得合适的时候调用；另一个是输入输出必须结构化，从而保证系统的稳定性。&lt;/p>
&lt;h3 id="理解和调用现有的-api">理解和调用现有的 API&lt;/h3>
&lt;p>想让 GPT 理解某个 API 的功能，最佳的方式当然是开发者手动给 API 添加名字和具体的描述信息，包括输入和输出值的结构，和每个字段代表着什么意思，这能很大程度上影响 GPT 的判断，最后决定是否调用该 API。&lt;/p>
&lt;p>如 OpenAI 官网中 &lt;a href="https://openai.com/blog/function-calling-and-other-api-updates">function calling 例子&lt;/a>中，关于调用天气 API 的描述如下所示。&lt;/p>
&lt;pre tabindex="0">&lt;code>function_descriptions = [
{
&amp;#34;name&amp;#34;: &amp;#34;get_current_weather&amp;#34;,
&amp;#34;description&amp;#34;: &amp;#34;Get the current weather in a given location&amp;#34;,
&amp;#34;parameters&amp;#34;: {
&amp;#34;type&amp;#34;: &amp;#34;object&amp;#34;,
&amp;#34;properties&amp;#34;: {
&amp;#34;location&amp;#34;: {
&amp;#34;type&amp;#34;: &amp;#34;string&amp;#34;,
&amp;#34;description&amp;#34;: &amp;#34;The city and state, e.g. San Francisco, CA&amp;#34;,
},
&amp;#34;unit&amp;#34;: {
&amp;#34;type&amp;#34;: &amp;#34;string&amp;#34;,
&amp;#34;description&amp;#34;: &amp;#34;The temperature unit to use. Infer this from the users location.&amp;#34;,
&amp;#34;enum&amp;#34;: [&amp;#34;celsius&amp;#34;, &amp;#34;fahrenheit&amp;#34;]
},
},
&amp;#34;required&amp;#34;: [&amp;#34;location&amp;#34;],
},
}
]
&lt;/code>&lt;/pre>&lt;p>上面的方法详细描述了如果需要调用该函数，至少需要提供当前所在的位置信息，并且可以选择性的提供温度单位。GPT 会根据问题是否和该函数的描述相关联，来决定是否调用该函数。具体的代码细节以后有几乎再写一篇，暂时不展开。&lt;/p>
&lt;p>我们可以通过提供大量的 APIs 的说明文档，让 LLMs 理解并学会这些 APIs 的功能、使用方式、组合方式。最终达到根据提出的总体要求，将总体要求拆分为多个子任务，具体子任务再与某个 API 进行交互，最终达到自动化以及 AI 的目标。&lt;/p>
&lt;p>我们这里描述的现有 APIs 并不仅仅是基于 HTTP 的请求，可以包括转化为 SQL 查询数据库，调用 SDK 实现复杂功能，甚至在未来，可以扩展为调用物理世界里面的开关、机械臂等。个人认为，基于目前已有的 GPT 能力和发展趋势，人机交互的方式将产生巨大的变化。&lt;/p>
&lt;h3 id="结构化输出">结构化输出&lt;/h3>
&lt;p>除了让 GPT 理解和调用现有的 API 之外，还需要让 GPT 输出的结果能够被现有系统所理解，这就需要 GPT 输出的结果是结构化的，例如 JSON 格式的数据。&lt;/p>
&lt;p>那么你可能马上想到，我们通过 prompt 不就可以实现这种功能吗？在大部分情况下确实可以，但是有些少量的情况，prompt 并不如 function calling 的方式稳定，而我们传统的系统，对于稳定性的要求是非常高的，举个例子。&lt;/p>
&lt;pre tabindex="0">&lt;code>student_description=小王是北京大学计算机科学专业的二年级学生，绩点为 3.8 GPA。他的编程很厉害，是该大学机器人俱乐部的活跃成员。他希望在毕业后追求人工智能方面的工作。
&lt;/code>&lt;/pre>&lt;p>这段话中，我们可以通过 prompt 来要求输出的结构为 json 格式，例如 prompt 为&lt;/p>
&lt;pre tabindex="0">&lt;code>Please extract the following information from the given text and return it as a JSON object:
name
major
school
grades
club
This is the body of text to extract the information from:
{student_1_description}
&lt;/code>&lt;/pre>&lt;p>但是比较难处理的是，我们没有办法能够确定 GPT 最终会输出的 grades 是 &lt;code>3.8&lt;/code> 还是 &lt;code>3.8 GPA&lt;/code>，这两种输出结果对于人类来讲没有如何区别，但是对于计算机来讲，这两种输出结果是完全不同的，前者是一个浮点数，后者是一个字符串。对于某些语言来讲转换就会直接出错。&lt;/p>
&lt;p>我们当然可以通过增加 prompt 的描述来减少这类问题，但是现实情况是比较复杂的，我们很难通过自然语言完全描述清楚需求，很难保证 GPT 的回答会每次都保持相同的输出。所以针对于这类问题，通过 OpenAI 提供的 function calling 的方式，能够在一定程度上解决自然语言与机器语言交互的问题。&lt;/p>
&lt;p>就像上述的问题可以描述为一个函数，我们将 grades 这个字段描述为 integer 来避免这类问题。这种结构化的能力对于开发一个稳定的系统是至关重要的。&lt;/p>
&lt;pre tabindex="0">&lt;code>student_custom_functions = [
{
&amp;#39;name&amp;#39;: &amp;#39;extract_student_info&amp;#39;,
&amp;#39;description&amp;#39;: &amp;#39;Get the student information from the body of the input text&amp;#39;,
&amp;#39;parameters&amp;#39;: {
&amp;#39;type&amp;#39;: &amp;#39;object&amp;#39;,
&amp;#39;properties&amp;#39;: {
&amp;#39;name&amp;#39;: {
&amp;#39;type&amp;#39;: &amp;#39;string&amp;#39;,
&amp;#39;description&amp;#39;: &amp;#39;Name of the person&amp;#39;
},
&amp;#39;major&amp;#39;: {
&amp;#39;type&amp;#39;: &amp;#39;string&amp;#39;,
&amp;#39;description&amp;#39;: &amp;#39;Major subject.&amp;#39;
},
&amp;#39;school&amp;#39;: {
&amp;#39;type&amp;#39;: &amp;#39;string&amp;#39;,
&amp;#39;description&amp;#39;: &amp;#39;The university name.&amp;#39;
},
&amp;#39;grades&amp;#39;: {
&amp;#39;type&amp;#39;: &amp;#39;integer&amp;#39;,
&amp;#39;description&amp;#39;: &amp;#39;GPA of the student.&amp;#39;
},
&amp;#39;club&amp;#39;: {
&amp;#39;type&amp;#39;: &amp;#39;string&amp;#39;,
&amp;#39;description&amp;#39;: &amp;#39;School club for extracurricular activities. &amp;#39;
}
}
}
}
]
&lt;/code>&lt;/pre>&lt;p>完整的调试过程可以去看看这个&lt;a href="https://www.datacamp.com/tutorial/open-ai-function-calling-tutorial">OpenAI function calling 的例子&lt;/a>。&lt;/p>
&lt;h2 id="gpt-应用需求分析">GPT 应用需求分析&lt;/h2>
&lt;p>上面主要是关于如何开发 GPT 应用的一些技巧，但是如果想要创造产品，我们还是需要从业务需求出发，去思考我们能够创造出什么样的业务价值，从而满足当前潜在用户的需求。&lt;/p>
&lt;blockquote>
&lt;p>2023/09/06 更新：LangChain 官方文档更新，将文档分为 RAG(RetrievalAugmentedGeneration) 和 Agents 两部分。这说明从 GPT 爆发几个月以来，工业界目前也觉得 RAG 和 Agents 是业务需求落地的两个方向。其中 RAG 就是我们上面主要讲的 GPT Embeddings 部分，后续我们会也从这两个方向举例说明。我觉得锚定像 langchain 这样的头部框架对于开发者来讲是非常有价值的，因为它们会在业务落地的过程中，总结出一些最佳实践和经验，这些经验对于开发者理解业务需求有很帮助。&lt;/p>
&lt;/blockquote>
&lt;h3 id="内容生成">内容生成&lt;/h3>
&lt;p>内容生成是目前最主流的需求，也是当前 AI 应用中流量统计最高的一个方向。除了 ChatGPT 这样大家所知的产品外，还有像 &lt;a href="https://beta.character.ai/">Character AI&lt;/a> 这样主要基于 Prompt 开发的人工智能伴侣（角色扮演类）应用流量也是非常的高。&lt;/p>
&lt;p>在更广泛的内容生成类中，图像生成领域如 &lt;a href="https://www.midjourney.com/">Midjourney&lt;/a>，语音生成领域如 &lt;a href="https://elevenlabs.io">ElevenLabs&lt;/a>。文字创意类领域如 &lt;a href="https://www.copy.ai/">copy ai&lt;/a>，还包括一些细分领域的文字内容生成，如小说生成辅助 &lt;a href="https://ai-novel.com/">AI-Novel&lt;/a> 等等。&lt;/p>
&lt;p>内容生成是当前互联网流量最高的 AI 需求领域，也是最容易落地的领域，因为它的应用场景非常广泛，内容生成辅助往往能够直接提高生产力，所以付费意愿往往不低，对于这个领域的争夺，往往也是最激烈的。&lt;/p>
&lt;h3 id="gpt-embeddings-需求">GPT Embeddings 需求&lt;/h3>
&lt;p>GPT Embeddings 是我觉得是非常有潜在价值的方向，其中 &lt;a href="https://github.com/guangzhengli/ChatFiles">ChatFiles&lt;/a> 刚开源不久的时候，我就收到了一些的咨询，问能否在客服、销售、操作手册、知识库等场景下优化现有场景和业务，我个人的回答是 GPT Embeddings 在这些场景下是非常有前景的。&lt;/p>
&lt;p>这个领域目前能看到的创业企业像 &lt;a href="https://www.mendable.ai">mendable ai&lt;/a> 就已经占据了一定的市场份额，支持了像 &lt;a href="https://js.langchain.com/">LangChain&lt;/a> 等头部 GPT 框架的文档问答功能。并且还在积极扩展销售、客户等业务场景。&lt;/p>
&lt;p>除此之外，这个领域目前流量最高的当属于 &lt;a href="https://www.chatpdf.com">ChatPDF&lt;/a> 这个网站，可以上传 PDF 文件，然后基于 PDF 提出问题和需求如总结等。这个方向也衍生出各个细分领域的需求，如辅助论文阅读和协作的像 &lt;a href="https://jenni.ai">Jenni AI&lt;/a> 等。&lt;/p>
&lt;h3 id="gpt-agents-需求">GPT Agents 需求&lt;/h3>
&lt;p>GPT Agents 的需求五花八门的，因为它是基于现有系统的集成，所以我们可以通过分析现有系统的 API 来确定我们能够创造出什么样的业务价值。例如很多 GPT 提供的联网功能就是通过集成 SerpAPI 来实现的，这是一个集成了各大搜索引擎的聚合查询网站，这样就能够让 ChatGPT 能够回答一些基于搜索的问题，如当前天气、股市、新闻等等。&lt;/p>
&lt;p>其中比较出名的自然是 &lt;a href="https://github.com/Significant-Gravitas/Auto-GPT">Auto GPT&lt;/a> 和 &lt;a href="https://github.com/reworkd/AgentGPT">AgentGPT&lt;/a> 这两个项目，如果对 GPT Agents 应用感兴趣，不妨看看这两个项目。除此之外，也许像 &lt;a href="https://github.com/calcom/cal.com/tree/main/apps/ai">cal.com&lt;/a> 这样的公司集成 AI agents 来使用自然语言增强预定会议这样的功能，也许能够给你一些不一样的启发。&lt;/p>
&lt;h3 id="非结构化输入和结构化输出">非结构化输入和结构化输出&lt;/h3>
&lt;p>还有就是我觉得被很多人忽视的一点是 GPT/LLM 处理非结构化数据的能力。在过去，我们想要处理一些简单的文本都是需要耗费大量开发时间的，例如从短信中提取出一些关键信息，例如姓名、电话号码、地址等等，由于不同的短信模版不同，所以这些信息都是非结构化。&lt;/p>
&lt;p>我们无法通过一个简单方法，就能够将这些内容转成 Json 等格式的结构化输出，所以我们往往需要通过一套复杂的正则表达式，或者 NLP 技术来将这些信息提取出来。但是正则表达式开发复杂，对于不同的短信模版，再加上模版会随着时间不短的改变，我们需要不断的调整正则表达式，这个过程是非常消耗开发时间和工程师精力的。&lt;/p>
&lt;p>NLP 技术又只能针对于某一些特定的场景，例如提取电话号码，提取地址等等，对于不同的场景，我们需要不同的 NLP 技术，所以一旦业务需求发生了变化，例如识别车牌，我们还需要重新开发和调整。&lt;/p>
&lt;p>但是有了 OpenAI GPT 这样统一的一个 API，我们只需要给服务提供不同的 Prompt，就可以通过 Prompt 来引导 GPT 进行推理，从而得到我们想要的结果。这样就能够大大的简化我们的开发流程，缩短开发时间，从而快速的响应市场的变化。&lt;/p>
&lt;p>并且由于 GPT 的强大的泛化能力，我们只需要针对于不同的场景，思考好如何处理非结构化数据即可。这种处理非结构化数据的能力，在未来软件开发中会改变很多以往业务的开发流程和方式，对于软件的生命周期将产生深远的影响。&lt;/p>
&lt;h3 id="自然语言交互">自然语言交互&lt;/h3>
&lt;p>最后我想说的是，GPT 能够处理自然语言的能力将深度改变人类与机器的交互方式。在过去，从命令行到图形界面，再到触摸屏，这些都是人机交互的变革史。大多数人和机器的交互方式其实是需要程序员这个载体的，人们有各种需求，业务分析师和开发人员将需求挖掘出来，由程序员通过代码的方式产生图形页面，人们再和图形页面产生交互，从而达到人机交互的能力。&lt;/p>
&lt;p>这个过程是信息传递损失的，并且产生了大量的限制和成本。如果机器能够理解自然语言，我们能够直接和机器进行交互，那么软件、机器、智能这几个我们熟悉的概念将会发生巨大的变化，人机交互也将发生翻天覆地的变化。&lt;/p>
&lt;p>如果你很难理解这种不确定的、没有任何参考的变化，可以去感受一下 &lt;a href="https://github.com/KillianLucas/open-interpreter">open interpreter&lt;/a> 这个项目，它是基于自然语言产生代码，并在电脑上直接执行的项目，虽然非常的原始和不稳定，但从中可以看到未来人机交互的变革。&lt;/p>
&lt;h2 id="references">References&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://github.com/guangzhengli/ChatFiles">https://github.com/guangzhengli/ChatFiles&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/guangzhengli/vectorhub">https://github.com/guangzhengli/vectorhub&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://js.langchain.com/docs/modules/data_connection">https://js.langchain.com/docs/modules/data_connection&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.datacamp.com/tutorial/open-ai-function-calling-tutorial">https://www.datacamp.com/tutorial/open-ai-function-calling-tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openai.com/blog/function-calling-and-other-api-updates">https://openai.com/blog/function-calling-and-other-api-updates&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://openai.com/blog/chatgpt-plugins#code-interpreter">https://openai.com/blog/chatgpt-plugins#code-interpreter&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/KillianLucas/open-interpreter">https://github.com/KillianLucas/open-interpreter&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.chatpdf.com">https://www.chatpdf.com&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://jenni.ai">https://jenni.ai&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/reworkd/AgentGPT">https://github.com/reworkd/AgentGPT&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://a16z.com/how-are-consumers-using-generative-ai">https://a16z.com/how-are-consumers-using-generative-ai&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>向量数据库</title><link>https://guangzhengli.com/blog/zh/vector-database/</link><pubDate>Sat, 15 Jul 2023 15:15:00 +0800</pubDate><author>iguangzhengli@gmail.com (Guangzheng Li)</author><guid>https://guangzhengli.com/blog/zh/vector-database/</guid><description>&lt;p>也许你最近可能听过这样的新闻，某向量数据库的初创公司刚写好 PPT，就获得了几千万的投资，某公司的开源的向量数据库因其代码的简陋而登上了 Hackernews 等等。在过去几个月时间中， AI 应用的发展如火如荼，带动了 AI 应用技术栈上下游的火爆，而向量数据库就是其中最热门的之一。&lt;/p>
&lt;p>笔者最近因为开发 &lt;a href="https://github.com/guangzhengli/ChatFiles">ChatFiles&lt;/a> 和 &lt;a href="https://github.com/guangzhengli/vectorhub">VectorHub&lt;/a> 两款开源项目的需要从而对向量数据库（Vector Database）进行了学习，在对主流的向量数据库和搜索算法有了大概的了解后，笔者决定将这些知识整理成一篇文章，希望能够帮助到大家。&lt;/p>
&lt;h2 id="gpt-的缺陷">GPT 的缺陷&lt;/h2>
&lt;p>过去几个月的时间，我们正处于人工智能的革命中，其中最耀眼的莫过于 GPT-3.5/4 的横空出世，而 GPT-3.5/4 带给我们无限震撼的同时，其天然的缺陷和诸多的限制也让开发者头痛不已，例如其输入端上下文（tokens）大小的限制困扰着很多的开发者和消费者，像 gpt-3.5-turbo 模型它的限制是 4K tokens(～3000字)，这意味着使用者最多只能输入 3000 字给 GPT 来理解和推理答案。&lt;/p>
&lt;p>有人可能会疑惑，我使用的 ChatGPT 是有对话记忆功能的，既然它可以做到聊天记忆，那么它的输入端 token 有限制也没什么关系，只要我将给 ChatGPT 的文字内容拆分成多次输入，它自然就可以记住我之前的对话，从而做到解除 token 限制。&lt;/p>
&lt;p>这个想法是不太正确的，GPT 作为 LLM 模型是没有记忆功能的，所谓的记忆功能只是开发者将对话记录存储在内存或者数据库中，当你发送消息给 gpt 模型时，程序会自动将最近的几次对话记录（基于对话的字数限制在 4096 tokens 内）通过 prompt 组合成最终的问题，并发送给 ChatGPT。简而言之，如果你的对话记忆超过了 4096 tokens，那么它就会忘记之前的对话，这就是目前 GPT 在需求比较复杂的任务中无法克服的缺陷。&lt;/p>
&lt;p>目前，不同模型对于 token 的限制也不同，gpt-4 是 32K tokens 的限制，而目前最大的 token 限制是 &lt;a href="https://www.anthropic.com/index/100k-context-windows">Claude 模型的 100K&lt;/a>，这意味可以输入大约 75000 字的上下文给 GPT，这也意味着 GPT 直接理解一部《哈利波特》的所有内容并回答相关问题。&lt;/p>
&lt;p>但这样就能解决我们所有的问题了吗？答案是否定的，首先 Claude 给出的例子是 GPT 处理 72K tokens 上下文的响应速度是 22 秒。如果我们拥有 GB 级别或更大的文档需要进行 GPT 理解和问答，目前的算力很难带来良好体验，更关键的是目前 GPT API 的价格是按照 tokens 来收费的，所以输入的上下文越多，其价格越按昂贵。&lt;/p>
&lt;p>这种情况有点类似于早期开发者面对内存只有几 MB 甚至几 KB 时期开发应用的窘境，一是‘内存’昂贵，二是‘内存’太小，所以在 GPT 模型在性能、成本、注意力机制等方面有重大革命性进展前，开发者不得不面对的绕过 GPT tokens 限制的难题。&lt;/p>
&lt;h2 id="向量数据库的崛起">向量数据库的崛起&lt;/h2>
&lt;p>在 GPT 模型的限制下，开发者们不得不寻找其他的解决方案，而向量数据库就是其中之一。向量数据库的核心思想是将文本转换成向量，然后将向量存储在数据库中，当用户输入问题时，将问题转换成向量，然后在数据库中搜索最相似的向量和上下文，最后将文本返回给用户。&lt;/p>
&lt;p>当我们有一份文档需要 GPT 处理时，例如这份文档是客服培训资料或者操作手册，我们可以先将这份文档的所有内容转化成向量（这个过程称之为 Vector Embedding），然后当用户提出相关问题时，我们将用户的搜索内容转换成向量，然后在数据库中搜索最相似的向量，匹配最相似的几个上下文，最后将上下文返回给 GPT。这样不仅可以大大减少 GPT 的计算量，从而提高响应速度，更重要的是降低成本，并绕过 GPT 的 tokens 限制。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/Embedding.png" alt="Embedding">&lt;/p>
&lt;p>再比如我们和 ChatGPT 之间有一份很长的对话，我们可以将所有对话以向量的方式保存起来，当我们提问给 ChatGPT 时，我们可以将问题转化为向量对过去所有的聊天记录进行语义搜索，找到与当前问题最相关的‘记忆’，一起发送给 ChatGPT，极大的提高 GPT 的输出质量。&lt;/p>
&lt;p>向量数据库的作用当然不止步于文字语义搜索，在传统的 AI 和机器学习场景中，还包含人脸识别、图像搜索、语音识别等功能，但不可否认的是，这一轮向量数据库的火爆，正是因为它对于 AI 获得理解和维护长期记忆以执行复杂任务时有非常大的帮助。例如你可以试试 &lt;a href="https://js.langchain.com/docs/">LangChainJs 的文档搜索/Q&amp;amp;A 功能&lt;/a> 感受它的魅力，或者可以试试笔者的开源项目 &lt;a href="https://github.com/guangzhengli/vectorhub">VectorHub&lt;/a> 和 &lt;a href="https://github.com/guangzhengli/ChatFiles">ChatFiles&lt;/a>，可以上传一份文档或者基于一份网页文档，然后询问文档相关问题。这些功能都是基于 Vector Embedding 和向量数据库的产品。&lt;/p>
&lt;h2 id="vector-embeddings">Vector Embeddings&lt;/h2>
&lt;p>对于传统数据库，搜索功能都是基于不同的索引方式（B Tree、倒排索引等）加上精确匹配和排序算法（BM25、TF-IDF）等实现的。本质还是基于文本的精确匹配，这种索引和搜索算法对于关键字的搜索功能非常合适，但对于语义搜索功能就非常弱。&lt;/p>
&lt;p>例如，如果你搜索“小狗”，那么你只能得到带有“小狗”关键字相关的结果，而无法得到“柯基”、“金毛”等结果，因为“小狗”和“金毛”是不同的词，传统数据库无法识别它们的语义关系，所以传统的应用需要人为的将“小狗”和“金毛”等词之间打上特征标签进行关联，这样才能实现语义搜索。而如何将生成和挑选特征这个过程，也被称为 Feature Engineering (特征工程)，它是将原始数据转化成更好的表达问题本质的特征的过程。&lt;/p>
&lt;p>但是如果你需要处理非结构化的数据，就会发现非结构化数据的特征数量会开始快速膨胀，例如我们处理的是图像、音频、视频等数据，这个过程就变得非常困难。例如，对于图像，可以标注颜色、形状、纹理、边缘、对象、场景等特征，但是这些特征太多了，而且很难人为的进行标注，所以我们需要一种自动化的方式来提取这些特征，而这可以通过 Vector Embedding 实现。&lt;/p>
&lt;p>Vector Embedding 是由 AI 模型（例如大型语言模型 LLM）生成的，它会根据不同的算法生成高维度的向量数据，代表着数据的不同特征，这些特征代表了数据的不同维度。例如，对于文本，这些特征可能包括词汇、语法、语义、情感、情绪、主题、上下文等。对于音频，这些特征可能包括音调、节奏、音高、音色、音量、语音、音乐等。&lt;/p>
&lt;p>例如对于目前来说，文本向量可以通过 OpenAI 的 text-embedding-ada-002 模型生成，图像向量可以通过 clip-vit-base-patch32 模型生成，而音频向量可以通过 wav2vec2-base-960h 模型生成。这些向量都是通过 AI 模型生成的，所以它们都是具有语义信息的。&lt;/p>
&lt;p>例如我们将这句话 “Your text string goes here” 用 text-embedding-ada-002 模型进行文本 Embedding，它会生成一个 1536 维的向量，得到的结果是这样：&lt;code>“-0.006929283495992422, -0.005336422007530928, ... -4547132266452536e-05,-0.024047505110502243”&lt;/code>，它是一个长度为 1536 的数组。这个向量就包含了这句话的所有特征，这些特征包括词汇、语法，我们可以将它存入向量数据库中，以便我们后续进行语义搜索。&lt;/p>
&lt;h2 id="特征和向量">特征和向量&lt;/h2>
&lt;p>虽然向量数据库的核心在于相似性搜索(Similarity Search)，但在深入了解相似性搜索前，我们需要先详细了解一下特征和向量的概念和原理。&lt;/p>
&lt;p>我们先思考一个问题？为什么我们在生活中区分不同的物品和事物？&lt;/p>
&lt;p>如果从理论角度出发，这是因为我们会通过识别不同事物之间不同的特征来识别种类，例如分别不同种类的小狗，就可以通过体型大小、毛发长度、鼻子长短等特征来区分。如下面这张照片按照体型排序，可以看到体型越大的狗越靠近坐标轴右边，这样就能得到一个体型特征的一维坐标和对应的数值，从 0 到 1 的数字中得到每只狗在坐标系中的位置。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/Snipaste_2023-07-15_20-55-09.png" alt="Snipaste_2023-07-15_20-55-09">&lt;/p>
&lt;p>然而单靠一个体型大小的特征并不够，像照片中哈士奇、金毛和拉布拉多的体型就非常接近，我们无法区分。所以我们会继续观察其它的特征，例如毛发的长短。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/Snipaste_2023-07-15_20-59-13.png" alt="Snipaste_2023-07-15_20-59-13">&lt;/p>
&lt;p>这样每只狗对应一个二维坐标点，我们就能轻易的将哈士奇、金毛和拉布拉多区分开来，如果这时仍然无法很好的区分德牧和罗威纳犬。我们就可以继续再从其它的特征区分，比如鼻子的长短，这样就能得到一个三维的坐标系和每只狗在三维坐标系中的位置。&lt;/p>
&lt;p>在这种情况下，只要特征足够多，就能够将所有的狗区分开来，最后就能得到一个高维的坐标系，虽然我们想象不出高维坐标系长什么样，但是在数组中，我们只需要一直向数组中追加数字就可以了。&lt;/p>
&lt;p>实际上，只要维度够多，我们就能够将所有的事物区分开来，世间万物都可以用一个多维坐标系来表示，它们都在一个高维的特征空间中对应着一个坐标点。&lt;/p>
&lt;p>那这和相似性搜索 (Similarity Search) 有什么关系呢？你会发现在上面的二维坐标中，德牧和罗威纳犬的坐标就非常接近，这就意味着它们的特征也非常接近。我们都知道向量是具有大小和方向的数学结构，所以可以将这些特征用向量来表示，这样就能够通过计算向量之间的距离来判断它们的相似度，这就是&lt;strong>相似性搜索&lt;/strong>。&lt;/p>
&lt;p>上面这几张图片和详细解释来源于&lt;a href="https://www.bilibili.com/video/BV11a4y1c7SW">这个视频&lt;/a>，这个视频系列也包含了部分下方介绍的相似性搜索算法。如果你对这个向量数据库感兴趣，非常推荐看看这个视频。&lt;/p>
&lt;h2 id="相似性搜索-similarity-search">相似性搜索 (Similarity Search)&lt;/h2>
&lt;p>既然我们知道了可以通过比较向量之间的距离来判断它们的相似度，那么如何将它应用到真实的场景中呢？如果想要在一个海量的数据中找到和某个向量最相似的向量，我们需要对数据库中的每个向量进行一次比较计算，但这样的计算量是非常巨大的，所以我们需要一种高效的算法来解决这个问题。&lt;/p>
&lt;p>高效的搜索算法有很多，其主要思想是通过两种方式提高搜索效率：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>减少向量大小——通过降维或减少表示向量值的长度。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>缩小搜索范围——可以通过聚类或将向量组织成基于树形、图形结构来实现，并限制搜索范围仅在最接近的簇中进行，或者通过最相似的分支进行过滤。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>我们首先来介绍一下大部分算法共有的核心概念，也就是聚类。&lt;/p>
&lt;h3 id="k-means-和-faiss">K-Means 和 Faiss&lt;/h3>
&lt;p>我们可以在保存向量数据后，先对向量数据先进行聚类。例如下图在二维坐标系中，划定了 4 个聚类中心，然后将每个向量分配到最近的聚类中心，经过聚类算法不断调整聚类中心位置，这样就可以将向量数据分成 4 个簇。每次搜索时，只需要先判断搜索向量属于哪个簇，然后再在这一个簇中进行搜索，这样就从 4 个簇的搜索范围减少到了 1 个簇，大大减少了搜索的范围。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/kmeans.png" alt="kmeans">&lt;/p>
&lt;p>常见的聚类算法有 K-Means，它可以将数据分成 k 个类别，其中 k 是预先指定的。以下是 k-means 算法的基本步骤：&lt;/p>
&lt;ol>
&lt;li>选择 k 个初始聚类中心。&lt;/li>
&lt;li>将每个数据点分配到最近的聚类中心。&lt;/li>
&lt;li>计算每个聚类的新中心。&lt;/li>
&lt;li>重复步骤 2 和 3，直到聚类中心不再改变或达到最大迭代次数。&lt;/li>
&lt;/ol>
&lt;p>但是这种搜索方式也有一些缺点，例如在搜索的时候，如果搜索的内容正好处于两个分类区域的中间，就很有可能遗漏掉最相似的向量。&lt;/p>
&lt;p>现实情况中，向量的分布也不会像图中一样区分的那么明显，往往区域的边界是相邻的，就像下图 &lt;a href="https://github.com/facebookresearch/faiss">Faiss 算法&lt;/a> 一样。&lt;/p>
&lt;p>我们可以将向量想象为包含在 Voronoi 单元格中 - 当引入一个新的查询向量时，首先测量其与质心 (centroids) 之间的距离，然后将搜索范围限制在该质心所在的单元格内。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/WUjl5M.jpg" alt="WUjl5M">&lt;/p>
&lt;p>那么为了解决搜索时可能存在的遗漏问题，可以将搜索范围动态调整，例如当 nprobe = 1 时，只搜索最近的一个聚类中心，当 nprobe = 2 时，搜索最近的两个聚类中心，根据实际业务的需求调整 nprobe 的值。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/FZadSG.jpg" alt="FZadSG">&lt;/p>
&lt;p>实际上，除了暴力搜索能完美的搜索出最相邻，所有的搜索算法只能在速度和质量还有内存上做一个权衡，这些算法也被称为近似最相邻（Approximate Nearest Neighbor）。&lt;/p>
&lt;h3 id="product-quantization-pq">Product Quantization (PQ)&lt;/h3>
&lt;p>在大规模数据集中，聚类算法最大的问题在于内存占用太大。这主要体现在两个方面，首先因为需要保存每个向量的坐标，而每个坐标都是一个浮点数，占用的内存就已经非常大了。除此之外，还需要维护聚类中心和每个向量的聚类中心索引，这也会占用大量的内存。&lt;/p>
&lt;p>对于第一个问题，可以通过量化 (Quantization) 的方式解决，也就是常见的有损压缩。例如在内存中可以将聚类中心里面每一个向量都用聚类中心的向量来表示，并维护一个所有向量到聚类中心的码本，这样就能大大减少内存的占用。&lt;/p>
&lt;p>但这仍然不能解决所有问题，在前面一个例子中，在二维坐标系中划分了聚类中心，同理，在高维坐标系中，也可以划定多个聚类中心点，不断调整和迭代，直到找到多个稳定和收敛的中心点。&lt;/p>
&lt;p>但是在高维坐标系中，还会遇到维度灾难问题，具体来说，随着维度的增加，数据点之间的距离会呈指数级增长，这也就意味着，在高维坐标系中，需要更多的聚类中心点将数据点分成更小的簇，才能提高分类的质量。否者，向量和自己的聚类中心距离很远，会极大的降低搜索的速度和质量。&lt;/p>
&lt;p>但如果想要维持分类和搜索质量，就需要维护数量庞大的聚类中心。随之而来会带来另一个问题，那就是聚类中心点的数量会随着维度的增加而指数级增长，这样会导致我们存储码本的数量极速增加，从而极大的增加了内存的消耗。例如一个 128 维的向量，需要维护 2^64 个聚类中心才能维持不错的量化结果，但这样的码本存储大小已经超过维护原始向量的内存大小了。&lt;/p>
&lt;p>解决这个问题的方法是将向量分解为多个子向量，然后对每个子向量独立进行量化，比如将 128 维的向量分为 8 个 16 维的向量，然后在 8 个 16 维的子向量上分别进行聚类，因为 16 维的子向量大概只需要 256 个聚类中心就能得到还不错的量化结果，所以就可以将码本的大小从 2^64 降低到 8 * 256 = 2048 个聚类中心，从而降低内存开销。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/5dAeV5.jpg" alt="5dAeV5">&lt;/p>
&lt;p>而将向量进行编码后，也将得到 8 个编码值，将它们拼起来就是该向量的最终编码值。等到使用的时候，只需要将这 8 个编码值，然后分别在 8 个子码本中搜索出对应的 16 维的向量，就能将它们使用笛卡尔积的方式组合成一个 128 维的向量，从而得到最终的搜索结果。这也就是乘积量化（Product Quantization）的原理。&lt;/p>
&lt;p>使用 PQ 算法，可以显著的减少内存的开销，同时加快搜索的速度，它唯一的问题是搜索的质量会有所下降，但就像我们刚才所讲，所有算法都是在内存、速度和质量上做一个权衡。&lt;/p>
&lt;h3 id="hierarchical-navigable-small-worlds-hnsw">Hierarchical Navigable Small Worlds (HNSW)&lt;/h3>
&lt;p>除了聚类以外，也可以通过构建树或者构建图的方式来实现近似最近邻搜索。这种方法的基本思想是每次将向量加到数据库中的时候，就先找到与它最相邻的向量，然后将它们连接起来，这样就构成了一个图。当需要搜索的时候，就可以从图中的某个节点开始，不断的进行最相邻搜索和最短路径计算，直到找到最相似的向量。&lt;/p>
&lt;p>这种算法能保证搜索的质量，但是如果图中所以的节点都以最短的路径相连，如图中最下面的一层，那么在搜索的时候，就同样需要遍历所有的节点。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/GD7ufK.jpg" alt="GD7ufK">&lt;/p>
&lt;p>解决这个问题的思路与常见的跳表算法相似，如下图要搜索跳表，从最高层开始，沿着具有最长“跳过”的边向右移动。如果发现当前节点的值大于要搜索的值-我们知道已经超过了目标，因此我们会在下一级中向前一个节点。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/wOu6JL.jpg" alt="wOu6JL">&lt;/p>
&lt;p>HNSW 继承了相同的分层格式，最高层具有更长的边缘（用于快速搜索），而较低层具有较短的边缘（用于准确搜索）。&lt;/p>
&lt;p>具体来说，可以将图分为多层，每一层都是一个小世界，图中的节点都是相互连接的。而且每一层的节点都会连接到上一层的节点，当需要搜索的时候，就可以从第一层开始，因为第一层的节点之间距离很长，可以减少搜索的时间，然后再逐层向下搜索，又因为最下层相似节点之间相互关联，所以可以保证搜索的质量，能够找到最相似的向量。&lt;/p>
&lt;p>如果你对跳表和 HNSW 感兴趣，可以看看&lt;a href="https://www.youtube.com/watch?v=QvKMwLjdK-s&amp;amp;t=168s&amp;amp;ab_channel=JamesBriggs">这个视频&lt;/a>。&lt;/p>
&lt;p>HNSW 算法是一种经典的空间换时间的算法，它的搜索质量和搜索速度都比较高，但是它的内存开销也比较大，因为不仅需要将所有的向量都存储在内存中。还需要维护一个图的结构，也同样需要存储。所以这类算法需要根据实际的场景来选择。&lt;/p>
&lt;h3 id="locality-sensitive-hashing-lsh">Locality Sensitive Hashing (LSH)&lt;/h3>
&lt;p>局部敏感哈希（Locality Sensitive Hashing）也是一种使用近似最近邻搜索的索引技术。它的特点是快速，同时仍然提供一个近似、非穷举的结果。LSH 使用一组哈希函数将相似向量映射到“桶”中，从而使相似向量具有相同的哈希值。这样，就可以通过比较哈希值来判断向量之间的相似度。&lt;/p>
&lt;p>通常，我们设计的哈希算法都是力求减少哈希碰撞的次数，因为哈希函数的搜索时间复杂度是 O(1)，但是，如果存在哈希碰撞，即两个不同的关键字被映射到同一个桶中，那么就需要使用链表等数据结构来解决冲突。在这种情况下，搜索的时间复杂度通常是 O(n)，其中n是链表的长度。所以为了提高哈希函数的搜索的效率，通常会将哈希函数的碰撞概率尽可能的小。&lt;/p>
&lt;p>但是在向量搜索中，我们的目的是为了找到相似的向量，所以可以专门设计一种哈希函数，使得哈希碰撞的概率尽可能高，并且位置越近或者越相似的向量越容易碰撞，这样相似的向量就会被映射到同一个桶中。&lt;/p>
&lt;p>等搜索特定向量时，为了找到给定查询向量的最近邻居，使用相同的哈希函数将类似向量“分桶”到哈希表中。查询向量被散列到特定表中，然后与该表中的其他向量进行比较以找到最接近的匹配项。这种方法比搜索整个数据集要快得多，因为每个哈希表桶中的向量远少于整个空间中的向量数。&lt;/p>
&lt;p>那么这个哈希函数应该如何设计呢？为了大家更好理解，我们先从二维坐标系解释，如下所图示，在二维坐标系中可以通过随机生成一条直线，将二维坐标系划分为两个区域，这样就可以通过判断向量是否在直线的同一边来判断它们是否相似。例如下图通过随机生成 4 条直线，这样就可以通过 4 个二进制数来表示一个向量的位置，例如 A 和 B 表示向量在同一个区域。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/lsh2.png" alt="lsh2">&lt;/p>
&lt;p>这个原理很简单，如果两个向量的距离很近，那么它们在直线的同一边的概率就会很高，例如直线穿过 AC 的概率就远大于直线穿过 AB 的概率。所以 AB 在同一侧的概率就远大于 AC 在同一侧的概率。&lt;/p>
&lt;p>当搜索一个向量时，将这个向量再次进行哈希函数计算，得到相同桶中的向量，然后再通过暴力搜索的方式，找到最接近的向量。如下图如果再搜索一个向量经过了哈希函数，得到了 10 的值，就会直接找到和它同一个桶中相似的向量 D。从而大大减少了搜索的时间。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/lsh3.png" alt="lsh3">&lt;/p>
&lt;p>关于更多 LSH 算法的细节，可以参考&lt;a href="https://www.pinecone.io/learn/series/faiss/locality-sensitive-hashing/">这篇博客&lt;/a>。&lt;/p>
&lt;h4 id="random-projection-for-lsh-随机投影">Random Projection for LSH 随机投影&lt;/h4>
&lt;p>如果在二维坐标系可以通过随机生成的直线区分相似性，那么同理，在三维坐标系中，就可以通过随机生成一个平面，将三维坐标系划分为两个区域。在多维坐标系中，同样可以通过随机生成一个超平面，将多维坐标系划分为两个区域，从而区分相似性。&lt;/p>
&lt;p>但是在高维空间中，数据点之间的距离往往非常稀疏，数据点之间的距离会随着维度的增加呈指数级增长。导致计算出来的桶非常多，最极端的情况是每个桶中就一个向量，并且计算速度非常慢。所以实际上在实现 LSH 算法的时候，会考虑使用随机投影的方式，将高维空间的数据点投影到低维空间，从而减少计算的时间和提高查询的质量。&lt;/p>
&lt;p>随机投影背后的基本思想是使用随机投影矩阵将高维向量投影到低维空间中。创建一个由随机数构成的矩阵，其大小将是所需的目标低维值。然后，计算输入向量和矩阵之间的点积，得到一个被投影的矩阵，它比原始向量具有更少的维度但仍保留了它们之间的相似性。&lt;/p>
&lt;p>当我们查询时，使用相同的投影矩阵将查询向量投影到低维空间。然后，将投影的查询向量与数据库中的投影向量进行比较，以找到最近邻居。由于数据的维数降低了，搜索过程比在整个高维空间中搜索要快得多。&lt;/p>
&lt;p>其基本步骤是：&lt;/p>
&lt;ol>
&lt;li>从高维空间中随机选择一个超平面，将数据点投影到该超平面上。&lt;/li>
&lt;li>重复步骤 1，选择多个超平面，将数据点投影到多个超平面上。&lt;/li>
&lt;li>将多个超平面的投影结果组合成一个向量，作为低维空间中的表示。&lt;/li>
&lt;li>使用哈希函数将低维空间中的向量映射到哈希桶中。&lt;/li>
&lt;/ol>
&lt;p>同样，随机投影也是一种近似方法，并且投影质量取决于投影矩阵。通常情况下，随机性越大的投影矩阵，其映射质量就越好。但是生成真正随机的投影矩阵可能会计算成本很高，特别是对于大型数据集来说。关于更多 RP for LSH 算法的细节，可以参考&lt;a href="https://www.pinecone.io/learn/series/faiss/locality-sensitive-hashing-random-projection/">这篇博客&lt;/a>。&lt;/p>
&lt;h2 id="相似性测量-similarity-measurement">相似性测量 (Similarity Measurement)&lt;/h2>
&lt;p>上面我们讨论了向量数据库的不同搜索算法，但是还没有讨论如何衡量相似性。在相似性搜索中，需要计算两个向量之间的距离，然后根据距离来判断它们的相似度。&lt;/p>
&lt;p>而如何计算向量在高维空间的距离呢？有三种常见的向量相似度算法：欧几里德距离、余弦相似度和点积相似度。&lt;/p>
&lt;h3 id="欧几里得距离euclidean-distance">欧几里得距离（Euclidean Distance）&lt;/h3>
&lt;p>欧几里得距离是指两个向量之间的距离，它的计算公式为：&lt;/p>
&lt;p>$$d(\mathbf{A}, \mathbf{B}) = \sqrt{\sum_{i=1}^{n}(A_i - B_i)^2}$$&lt;/p>
&lt;p>其中，$\mathbf{A}$ 和 $\mathbf{B}$ 分别表示两个向量，$n$ 表示向量的维度。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/KPhJ27.jpg" alt="KPhJ27">&lt;/p>
&lt;p>欧几里得距离算法的优点是可以反映向量的绝对距离，适用于需要考虑向量长度的相似性计算。例如推荐系统中，需要根据用户的历史行为来推荐相似的商品，这时就需要考虑用户的历史行为的数量，而不仅仅是用户的历史行为的相似度。&lt;/p>
&lt;h3 id="余弦相似度cosine-similarity">余弦相似度（Cosine Similarity）&lt;/h3>
&lt;p>余弦相似度是指两个向量之间的夹角余弦值，它的计算公式为：&lt;/p>
&lt;p>$$\cos(\theta) = \frac{\mathbf{A} \cdot \mathbf{B}}{|\mathbf{A}| |\mathbf{B}|}$$&lt;/p>
&lt;p>其中，$\mathbf{A}$ 和 $\mathbf{B}$ 分别表示两个向量，$\cdot$ 表示向量的点积，$|\mathbf{A}|$ 和 $|\mathbf{B}|$ 分别表示两个向量的模长。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/fHLAfz.jpg" alt="fHLAfz">&lt;/p>
&lt;p>余弦相似度对向量的长度不敏感，只关注向量的方向，因此适用于高维向量的相似性计算。例如语义搜索和文档分类。&lt;/p>
&lt;h3 id="点积相似度-dot-product-similarity">点积相似度 (Dot product Similarity)&lt;/h3>
&lt;p>向量的点积相似度是指两个向量之间的点积值，它的计算公式为：&lt;/p>
&lt;p>$$\mathbf{A} \cdot \mathbf{B} = \sum_{i=1}^{n}A_i B_i$$&lt;/p>
&lt;p>其中，$\mathbf{A}$ 和 $\mathbf{B}$ 分别表示两个向量，$n$ 表示向量的维度。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/kyA3AN.jpg" alt="kyA3AN">&lt;/p>
&lt;p>点积相似度算法的优点在于它简单易懂，计算速度快，并且兼顾了向量的长度和方向。它适用于许多实际场景，例如图像识别、语义搜索和文档分类等。但点积相似度算法对向量的长度敏感，因此在计算高维向量的相似性时可能会出现问题。&lt;/p>
&lt;p>每一种相似性测量 (Similarity Measurement) 算法都有其优点和缺点，需要开发者根据自己的数据特征和业务场景来选择。&lt;/p>
&lt;h2 id="过滤-filtering">过滤 (Filtering)&lt;/h2>
&lt;p>在实际的业务场景中，往往不需要在整个向量数据库中进行相似性搜索，而是通过部分的业务字段进行过滤再进行查询。所以存储在数据库的向量往往还需要包含元数据，例如用户 ID、文档 ID 等信息。这样就可以在搜索的时候，根据元数据来过滤搜索结果，从而得到最终的结果。&lt;/p>
&lt;p>为此，向量数据库通常维护两个索引：一个是向量索引，另一个是元数据索引。然后，在进行相似性搜索本身之前或之后执行元数据过滤，但无论哪种情况下，都存在导致查询过程变慢的困难。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/VwZxFW.jpg" alt="VwZxFW">&lt;/p>
&lt;p>过滤过程可以在向量搜索本身之前或之后执行，但每种方法都有自己的挑战，可能会影响查询性能：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Pre-filtering：在向量搜索之前进行元数据过滤。虽然这可以帮助减少搜索空间，但也可能导致系统忽略与元数据筛选标准不匹配的相关结果。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Post-filtering：在向量搜索完成后进行元数据过滤。这可以确保考虑所有相关结果，在搜索完成后将不相关的结果进行筛选。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>为了优化过滤流程，向量数据库使用各种技术，例如利用先进的索引方法来处理元数据或使用并行处理来加速过滤任务。平衡搜索性能和筛选精度之间的权衡对于提供高效且相关的向量数据库查询结果至关重要。&lt;/p>
&lt;h2 id="向量数据库选型">向量数据库选型&lt;/h2>
&lt;p>笔者在本文中，花费了大量的笔墨来介绍向量数据库的相似性搜索算法的原理和实现，相似性搜索算法固然是一个向量数据库的核心和关键点，但是在实际的业务场景中，往往还需要考虑其它的因素，例如向量数据库的可用性、扩展性、安全性等，还有代码是否开源、社区是否活跃等等。&lt;/p>
&lt;h3 id="分布式">分布式&lt;/h3>
&lt;p>一个成熟的向量数据库，往往需要支持分布式部署，这样才能满足大规模数据的存储和查询。数据拥有的越多，需要节点就越多，出现的错误和故障也就越多，所以分布式的向量数据库需要具备高可用性和容错性。&lt;/p>
&lt;p>数据库的高可用性和容错性，往往需要实现分片和复制能力，在传统的数据库中，往往通过数据的主键或者根据业务需求进行分片，但是在分布式的向量数据库中，就需要考虑根据向量的相似性进行分区，以便查询的时候能够保证结果的质量和速度。&lt;/p>
&lt;p>其它类似复制节点数据的一致性、数据的安全性等等，都是分布式向量数据库需要考虑的因素。&lt;/p>
&lt;h3 id="访问控制和备份">访问控制和备份&lt;/h3>
&lt;p>除此之外，访问控制设计的是否充足，例如当组织和业务快速发展时，是否能够快速的添加新的用户和权限控制，是否能够快速的添加新的节点，审计日志是否完善等等，都是需要考虑的因素。&lt;/p>
&lt;p>另外，数据库的监控和备份也是一个重要的因素，当数据出现故障时，能够快速的定位问题和恢复数据，是一个成熟的向量数据库必须要考虑的因素。&lt;/p>
&lt;h3 id="api--sdk">API &amp;amp; SDK&lt;/h3>
&lt;p>对比上面的因素选择，API &amp;amp; SDK 可能是往往被忽略的因素，但是在实际的业务场景中，API &amp;amp; SDK 往往是开发者最关心的因素。因为 API &amp;amp; SDK 的设计直接影响了开发者的开发效率和使用体验。一个优秀良好的 API &amp;amp; SDK 设计，往往能够适应需求的不同变化，向量数据库是一个新的领域，在如今大部分人不太清楚这方面需求的当下，这一点容易被人忽视。&lt;/p>
&lt;h3 id="选型">选型&lt;/h3>
&lt;p>截至目前，汇总到目前的向量数据库有以下几种选择：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>向量数据库&lt;/th>
&lt;th>URL&lt;/th>
&lt;th>GitHub Star&lt;/th>
&lt;th>Language&lt;/th>
&lt;th>Cloud&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>chroma&lt;/td>
&lt;td>&lt;a href="https://github.com/chroma-core/chroma">https://github.com/chroma-core/chroma&lt;/a>&lt;/td>
&lt;td>7.4K&lt;/td>
&lt;td>Python&lt;/td>
&lt;td>❌&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>milvus&lt;/td>
&lt;td>&lt;a href="https://github.com/milvus-io/milvus">https://github.com/milvus-io/milvus&lt;/a>&lt;/td>
&lt;td>21.5K&lt;/td>
&lt;td>Go/Python/C++&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>pinecone&lt;/td>
&lt;td>&lt;a href="https://www.pinecone.io/">https://www.pinecone.io/&lt;/a>&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>❌&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>qdrant&lt;/td>
&lt;td>&lt;a href="https://github.com/qdrant/qdrant">https://github.com/qdrant/qdrant&lt;/a>&lt;/td>
&lt;td>11.8K&lt;/td>
&lt;td>Rust&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>typesense&lt;/td>
&lt;td>&lt;a href="https://github.com/typesense/typesense">https://github.com/typesense/typesense&lt;/a>&lt;/td>
&lt;td>12.9K&lt;/td>
&lt;td>C++&lt;/td>
&lt;td>❌&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>weaviate&lt;/td>
&lt;td>&lt;a href="https://github.com/weaviate/weaviate">https://github.com/weaviate/weaviate&lt;/a>&lt;/td>
&lt;td>6.9K&lt;/td>
&lt;td>Go&lt;/td>
&lt;td>✅&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="传统数据的扩展">传统数据的扩展&lt;/h3>
&lt;p>除了选择专业的向量数据库，使用传统数据库进行扩展也是一种方法。类似 Redis 除了传统的 Key Value 数据库用途外，Redis 还提供了 Redis Modules，这是一种通过新功能、命令和数据类型扩展 Redis 的方式。例如使用 &lt;a href="https://redis.io/docs/interact/search-and-query/">RediSearch&lt;/a> 模块来扩展向量搜索的功能。&lt;/p>
&lt;p>同理的还有 PostgreSQL 的扩展，PostgreSQL 提供使用 extension 的方式来扩展数据库的功能，例如 &lt;a href="https://github.com/pgvector/pgvector">pgvector&lt;/a> 来开启向量搜索的功能。它不仅支持精确和相似性搜索，还支持余弦相似度等相似性测量算法。最重要的是，它是附加在 PostgreSQL 上的，因此可以利用 PostgreSQL 的所有功能，例如 ACID 事务、并发控制、备份和恢复等。还拥有所有的 PostgreSQL 客户端库，因此可以使用任何语言的 PostgreSQL 客户端来访问它。可以减少开发者的学习成本和服务的维护成本。&lt;/p>
&lt;p>像笔者的开源项目 &lt;a href="https://github.com/guangzhengli/ChatFiles">ChatFiles&lt;/a> 和 &lt;a href="https://github.com/guangzhengli/vectorhub">VectorHub&lt;/a> 目前就暂时使用 pgvector 来实现向量搜索以实现 GPT 文档问答，基于 &lt;a href="https://supabase.com/blog/openai-embeddings-postgres-vector">Supabase 提供的 PostgreSQL + pgvector&lt;/a> 服务完成。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本文主要介绍了向量数据库的原理和实现，包括向量数据库的基本概念、相似性搜索算法、相似性测量算法、过滤算法和向量数据库的选型等等。向量数据库是崭新的领域，目前大部分向量数据库公司的估值乘着 AI 和 GPT 的东风从而飞速的增长，但是在实际的业务场景中，目前向量数据库的应用场景还比较少，抛开浮躁的外衣，向量数据库的应用场景还需要开发者们和业务专家们去挖掘。&lt;/p>
&lt;h2 id="references">References&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV11a4y1c7SW">https://www.bilibili.com/video/BV11a4y1c7SW&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1BM4y177Dk">https://www.bilibili.com/video/BV1BM4y177Dk&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.pinecone.io/learn/vector-database/">https://www.pinecone.io/learn/vector-database/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/guangzhengli/ChatFiles">https://github.com/guangzhengli/ChatFiles&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/guangzhengli/vectorhub">https://github.com/guangzhengli/vectorhub&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.anthropic.com/index/100k-context-windows">https://www.anthropic.com/index/100k-context-windows&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://js.langchain.com/docs/">https://js.langchain.com/docs/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.pinecone.io/learn/series/faiss/locality-sensitive-hashing/">https://www.pinecone.io/learn/series/faiss/locality-sensitive-hashing/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.pinecone.io/learn/series/faiss/product-quantization/">https://www.pinecone.io/learn/series/faiss/product-quantization/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.pinecone.io/learn/series/faiss/locality-sensitive-hashing-random-projection/">https://www.pinecone.io/learn/series/faiss/locality-sensitive-hashing-random-projection/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=QvKMwLjdK-s&amp;amp;t=168s&amp;amp;ab_channel=JamesBriggs">https://www.youtube.com/watch?v=QvKMwLjdK-s&amp;amp;t=168s&amp;amp;ab_channel=JamesBriggs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.pinecone.io/learn/series/faiss/faiss-tutorial/">https://www.pinecone.io/learn/series/faiss/faiss-tutorial/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=sKyvsdEv6rk&amp;amp;ab_channel=JamesBriggs">https://www.youtube.com/watch?v=sKyvsdEv6rk&amp;amp;ab_channel=JamesBriggs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.pinecone.io/learn/vector-similarity/">https://www.pinecone.io/learn/vector-similarity/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/chroma-core/chroma">https://github.com/chroma-core/chroma&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/milvus-io/milvus">https://github.com/milvus-io/milvus&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.pinecone.io/">https://www.pinecone.io/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/qdrant/qdrant">https://github.com/qdrant/qdrant&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/typesense/typesense">https://github.com/typesense/typesense&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/weaviate/weaviate">https://github.com/weaviate/weaviate&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://redis.io/docs/interact/search-and-query/">https://redis.io/docs/interact/search-and-query/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/pgvector/pgvector">https://github.com/pgvector/pgvector&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>把阅读作为方法</title><link>https://guangzhengli.com/blog/zh/reading/</link><pubDate>Sat, 18 Mar 2023 16:05:00 +0800</pubDate><author>iguangzhengli@gmail.com (Guangzheng Li)</author><guid>https://guangzhengli.com/blog/zh/reading/</guid><description>&lt;p>笔者刚上大学的时候，比较讨厌将阅读作为一种方法来讨论研究。认为读书唯求愉快，只在乎共鸣和是否获得了享受。当时笔者更追求的是读书不求甚解，对做研究般的读书方法是尽显鄙夷之态，对咬文嚼字般的读法更是嗤之以鼻。&lt;/p>
&lt;p>时过境迁，后续接触到了更复杂的学科，更加晦涩的知识后，对于知识也就有了更多的敬畏，并且慢慢发现自己的阅读方法和态度跟不上知识的要求，于是开始慢慢的探索起来，将目光重新放回到了阅读的方法论中，也就有了这一篇文章分享。&lt;/p>
&lt;h2 id="散漫的缺陷">散漫的缺陷&lt;/h2>
&lt;blockquote>
&lt;p>我在生活、感受、思考，把自己意识到的一些东西记录了下来。更多的东西尚未被我意识到，它们已经存在，仍处在沉睡和混沌之中。读书的时候，因为共鸣，因为抗争，甚至因为走神，沉睡的被唤醒了，混沌的变清晰了。对于我来说，读书的最大乐趣之一是自我发现，知道自己原来还有这么一些好东西。&lt;/p>
&lt;/blockquote>
&lt;p>最初的时候，互联网上的资讯并不多，我所有的阅读活动都是基于大学图书馆的藏书，大多数时间看的是王小波、余华、加缪、海明威等人的小说，那时认为散漫而随意的看书是一种生活态度，你不必记得你看过什么，就像你不必记得你哪天吃过什么一样，它们早就成为了你身体和精神的一部分。这种变化是滋润和成长型的，所以不必偃苗助长。&lt;/p>
&lt;p>这种理论直到现在我认为也有其合理之处，但是随着年龄的增长，接触到的学科和理论变多，这种散漫的阅读习惯还是带来了缺陷。最初让我感觉到吃力的是在大二期间接触了经济学，当时凭借着兴趣借阅了曼昆的&lt;a href="https://book.douban.com/subject/26435630/">《经济学原理》&lt;/a>，一口气读完了上下两册大部头。虽然阅读期间感觉重塑了自己的世界观，第一次有了一种解构世界的方法的喜悦，但是读完后心里反而空荡荡的，感觉这些知识犹如浮云般随时都会离自己而去。这和读完文学或者小说后的心态截然不同。&lt;/p>
&lt;p>直到我在读完 &lt;a href="https://book.douban.com/subject/1013208/">《如何阅读一本书》&lt;/a> 后，我才有开始意识到原来阅读不同种类的书籍，需要不同的阅读方法。就像读小说文学类书籍不求甚解可能是好事，但是阅读专业性书籍，如果不梳理大纲，不进行主题阅读，那么可能就无法说自己读好了这本书。&lt;/p>
&lt;blockquote>
&lt;p>主题阅读，也可以称作比较阅读，这是所有阅读中要求最高和难度最大的阅读类型。 主题阅读是&lt;strong>围绕某个主题同时阅读多种阅读材料，并进行对比、分析&lt;/strong>。 主题阅读的目标不是全面理解任何一种特定的阅读文本而是为了加深对于某个主题的理解。&lt;/p>
&lt;/blockquote>
&lt;p>在这之后，我有意识的开始探索阅读的方法，减轻阅读以外不必要的负担，经过较长时间的调整和修改，目前这一套方法是我迭代出的流程，虽然后续难免进行修补，但是核心流程已经经过时间的检验。&lt;/p>
&lt;p>我的阅读工作流分别是&lt;strong>发现、收集、计划、阅读和输出&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>发现：寻找感兴趣的、有价值的书籍。&lt;/li>
&lt;li>收集：通过工具收集书籍。&lt;/li>
&lt;li>计划：围绕 OKR 或者个人兴趣，构建特定的主题书单，制定阅读计划。&lt;/li>
&lt;li>阅读：针对不同种类书籍使用不同阅读方法。&lt;/li>
&lt;li>输出：用输出知识的方式加深知识理解。&lt;/li>
&lt;/ol>
&lt;h2 id="发现之旅">发现之旅&lt;/h2>
&lt;p>虽然如今互联网时代获取信息的媒介有很多，例如博客、网站、长短视频、线上交流等等，但是想要获得系统性的知识，书籍仍然是我认为最佳的实践没有之一。但这一切有一个前提，即阅读的对象必须是优质的内容，如果阅读劣质内容，则比其它媒介更容易使人陷入偏见和狭隘。&lt;/p>
&lt;p>所以阅读流程的第一步，就是寻找优秀的书籍。如果还要加上一个限定词，那就是寻找你感兴趣的优秀书籍。&lt;/p>
&lt;h3 id="寻找兴趣">寻找兴趣&lt;/h3>
&lt;p>比起从浩如烟海的经典书籍堆中寻找书籍开始阅读，从自身的兴趣出发也许是个更好的选择。与其强迫自己阅读完某些经典书籍，不如跟随着内心的喜好，从好奇心和阅读的欲望为起点，开始自己的阅读之旅。&lt;/p>
&lt;p>如果你对阅读哪本书籍还没有什么目标，暂时不清楚自己对哪类书籍感兴趣，那么不妨去书店逛逛。对比网上他人的推荐和电子书籍，纸质的书籍能给人提供更直接的反馈，亲手翻一翻书的目录和大致的内容，相信能很快的知道自己是否对该类型的书籍感兴趣。&lt;/p>
&lt;p>并且由于压力和竞争，现存的独立书店对书籍展示和陈列的方式都有独特的考量，经常看看书店的热门推荐位，也能快速找到新出版的好书。独立书店都有很强的个性，例如特定的类别或者作者，可以参考我&lt;a href="https://guangzhengli.com/art/zh/wuhan-bookstore/">闲逛武汉书店&lt;/a>的文章。像下面是在武汉视觉书屋拍摄的照片，整个书店陈列的都是艺术类书籍：&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/IMG_1025.jpeg" alt="IMG_1025">&lt;/p>
&lt;h3 id="寻找书籍">寻找书籍&lt;/h3>
&lt;p>如果你对逛书店兴趣寥寥，那么在互联网上也可以先通过优质的书单找到感兴趣的科目，例如&lt;a href="https://book.douban.com/top250">豆瓣 Top250&lt;/a> 可以找到大多数经过时间检验的经典书籍。如果对新书兴趣浓厚，那么关注一些特定领域的博主或许有所帮助。&lt;/p>
&lt;p>在阅读初期，个人建议不要太纠结该书是否足够优秀，只要稍有兴趣，就可以通过检视阅读(可以理解为略读)来判断一本书是否值得读，只有读过才知道该书是否感兴趣，是否值得读，如果对该主题不感兴趣，无非是换一本书而已。&lt;/p>
&lt;p>如果你本身已经有了感兴趣的科目或者书籍，那么可以通过以下方式寻找更多相关图书：&lt;/p>
&lt;ul>
&lt;li>本书作者还写过哪些书？例如如果你对《&lt;a href="https://book.douban.com/subject/25985021/">人类简史&lt;/a>》感兴趣，那么大概率尤瓦尔·赫拉利的简史三部曲都会符合你口味。&lt;/li>
&lt;li>本书是哪家出版社出品？例如笔者比较喜欢的&lt;a href="https://book.douban.com/press/2158">生活·读书·新知三联书店&lt;/a>出版的图书质量普遍都比较高。&lt;/li>
&lt;li>豆瓣中收藏了该书的豆瓣豆列或者书单？例如笔者在看完&lt;a href="https://book.douban.com/subject/3410718/">《美的历程》&lt;/a>后对中国美学和思想史开始有所兴趣，便通过&lt;a href="https://www.douban.com/doulist/1682019/">关于美学和审美&lt;/a>这个豆列书单打开了新的领域。&lt;/li>
&lt;li>另外不少作者会在序言或者末尾加上自己的推荐书目和参考书目，遇到类似情况按图索骥即可。&lt;/li>
&lt;/ul>
&lt;h2 id="收集之旅">收集之旅&lt;/h2>
&lt;h3 id="书籍归纳">书籍归纳&lt;/h3>
&lt;p>在发现了优秀的书籍之后，如果有条件立刻阅读完它当然是理想的。但往往现实并不如愿，我们往往会被各种工作和琐事占据时间。所以为了防止遗忘后续继续阅读，笔者往往需要做的一件事就是将它保存下来，并且尽可能的收集归纳后将它可视化。以便于后续准备阅读计划和主题阅读：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>一方面是因为我们无法做到当发现一本好书的时候，就可以立刻开始阅读它。特别是当进行主题阅读时，我们可能会一次性的阅读多本同类书籍，所以在阅读之前，还需要收集和归纳同类题材的书籍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>另一方面是由于感兴趣而收集来的书籍数量可能会远远超过你能计划的阅读数量，所以在阅读前，还需要进行计划性的挑选。看看是否满足主题阅读的需要，当前阅读的优先级等。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>首先第一步是将感兴趣的书籍归纳到一处。对于这一步的工具和流程需要：&lt;/p>
&lt;ul>
&lt;li>自动化：能自动添加书籍名称、作者、ISBN、封面等，也支持手动添加。&lt;/li>
&lt;li>灵活性：能添加删除书籍的字段，有助于更好的组织归纳。如书籍类别、看完日期，评分等。&lt;/li>
&lt;li>可视化：良好的页面支持，可定制化的展示自己需要的字段和图片。如陈列正在读、想读、已读等页面。&lt;/li>
&lt;li>笔记支持：与后续的输出相结合，与笔记合二为一有助于减轻管理的压力。&lt;/li>
&lt;/ul>
&lt;p>在这些需求下，目前我个人选择的产品是 &lt;a href="https://www.notion.so/">Notion&lt;/a>，它的数据库功能可以覆盖后三条需求，配合其 Chrome 插件 &lt;a href="https://chrome.google.com/webstore/detail/save-to-notion/ldmmifpegigmeammaeckplhnjbbpccmm">Save to notion&lt;/a> 可以完美实现第一条自动化功能。整体流程简单，定制化程度高，结合 notion 的页面风格设计简约、克制，所以综合起来是我个人最偏爱的方案，当然你也可以选择任何你喜欢的工具。&lt;/p>
&lt;p>其整个保存逻辑流程如下：&lt;/p>
&lt;p>首先在 notion 中定制一个图书资源的数据库，定制相关的数据库字段。诸如书籍名称、作者、读书状态、封面图片、类别等等。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/screenshotr_2023-3-19T16-44-26.png" alt="screenshotr_2023-3-19T16-44-26">&lt;/p>
&lt;p>其次可以通过该数据库组织视图，将&lt;code>在读书单&lt;/code>、&lt;code>想读书单&lt;/code>、&lt;code>已读书单&lt;/code>和&lt;code>计划书单&lt;/code>列在入口处，这样一个基本的图书馆系统就组织成功了。如果你也想要类似的效果，你可以通过点击 &lt;a href="https://guangzhengli.notion.site/Guangzheng-Book-Template-a446554b015748deb4c61559f99f9bf8">Guangzheng Book Template&lt;/a> 来复制模版创建一个属于你的数据库和书籍管理系统。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/screenshotr_2023-3-19T16-57-50.png" alt="screenshotr_2023-3-19T16-57-50">&lt;/p>
&lt;p>当你创建好一个数据库后，便可以开始将书籍自动化的保存到数据库中，目前中文书籍信息最全的地方还是&lt;a href="https://book.douban.com/">豆瓣读书&lt;/a>，所以我们针对豆瓣图书构建自动化流程。通过下载 Chrome 插件 &lt;a href="https://chrome.google.com/webstore/detail/save-to-notion/ldmmifpegigmeammaeckplhnjbbpccmm">Save to notion&lt;/a>，进入豆瓣某一本书的页面，点击 Notion Saver 图标，配置图书数据库和相应数据库字段，点击 Save 便可以轻易保存。配置如下图所示：&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/iIlR0O.png" alt="iIlR0O">&lt;/p>
&lt;p>整个自动化保存流程如下图 GIF 所示 (你可以通过右键打开新Tab重复观看)：&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/db061686-c348-4325-b3e5-d11632c7a396.gif" alt="db061686-c348-4325-b3e5-d11632c7a396">&lt;/p>
&lt;h2 id="计划阅读">计划阅读&lt;/h2>
&lt;p>从前文可以得知笔者之前一直都是随机阅读的爱好者，转向计划阅读最主要的一个因素就是主题阅读的需要。当你需要对一个理论或者现象进行辩证看待时，只看一个作者的观点往往容易陷入偏见，一本书往往难以窥视知识的全貌。&lt;/p>
&lt;p>为此我们需要对同一个问题，获取不同作者、不同角度的看法。诸如对于经济学中的国家干预主义与经济自由主义，凯恩斯与哈耶克两位同时代的经济学家可以得出完全相反的观点，这类例子在书籍和生活中数不胜数。需要我们保持平和、谦逊的态度对相关的知识进行主题阅读，才能有所收获。&lt;/p>
&lt;blockquote>
&lt;p>以前在读书的时候，容易对某本书或者某个作者产生崇拜，但是过了几年在重读这本书的时候，经常会产生失望感，也不太能理解当年为什么会如此狂热这本书或者人。以至于后面读书的时候，无论书写的多么有道理，多么的出色，也会默默的保持一定的距离。&lt;/p>
&lt;/blockquote>
&lt;p>其次是部分知识有较高的门槛，如果阅读不按顺序的话，容易无效阅读和磨损对其的兴趣。例如对明史没有任何了解，就直接读《万历十五年》，书中的草灰蛇线就容易被忽视，最后对书的评价也就截然不同。还有类似于哲学体系，很多理论都是继承前人扩展或者批判的，如果直接跳过前人理论就进行阅读则容易一头雾水。&lt;/p>
&lt;p>所以制定阅读计划是有助于构建个人的知识体系的，计划阅读并不是推荐你计划一年或一个月要读多少本书，而是要明确感兴趣的领域主题，列出主题书单，制定阅读顺序。&lt;/p>
&lt;p>对于书籍来说，你可以在 notion 中创建一个新的 Page 来存放书单，例如下面的经济学书单，你同样可以在 &lt;a href="https://guangzhengli.notion.site/Guangzheng-Book-Template-a446554b015748deb4c61559f99f9bf8">Guangzheng Book Template&lt;/a> 中找到这个页面：&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/screenshotr_2023-3-19T18-31-29.png" alt="screenshotr_2023-3-19T18-31-29">&lt;/p>
&lt;p>当计划制定完成后，通常计划书单中的书籍数量往往比实际能阅读的要多，这时还可以继续进行删减，保证阅读内容的质量进一步的提高。&lt;/p>
&lt;h2 id="阅读">阅读&lt;/h2>
&lt;p>当计划制定好并开始阅读时，笔者建议除了阅读本身之外一切事物都放弃纠结和比较。我看过很多关于阅读的讨论与争吵，诸如阅读设备的选择？纸质还是电子？电子书的阅读软件选择等等。笔者认为这些比较和选择毫无意义，没有任何的设备能代替你的思考，也没有任何的工具能代替你与作者对话。&lt;/p>
&lt;p>笔者小时候通过在书店租书的方式租凭阅读，大学时期从图书馆借阅图书，工作后租房于是选择电子阅读的方式。这些不同的阅读方式对于我阅读本身并没有任何区别，同样是与作者的灵魂对话，用纸质书或者昂贵的电子设备并不会让这个过程变得更加顺利。&lt;/p>
&lt;p>当然如果从阅读效率来讲，笔者还是需要承认，买书不如借书！借书不如租书！租来的图书往往比买来的图书看的更香！人类的懒惰和劣根性这一刻在我身上还是体现的淋漓尽致！所以如果大家有借阅图书的条件，不妨试试。&lt;/p>
&lt;p>总而言之，这一节笔者并不推荐任何的设备或者工具来辅助阅读，并建议读者放弃对阅读工具投入时间，专注阅读本身！多阅读一本书内容本身，比起将时间花费在阅读工具、方式和流程要来的更加有价值，希望大家共勉！&lt;/p>
&lt;p>当然，对于阅读的方法，并不局限于工具，还有一些认知层面需要进行方法性的思考。例如不同类别的书籍该如何阅读？不同难度的书籍应该如何选择？&lt;/p>
&lt;h3 id="分类阅读">分类阅读&lt;/h3>
&lt;p>在阅读前，我们往往就需要对一个书籍的分类有所了解，这样有助于辩证的看待问题和知识。&lt;/p>
&lt;p>例如阅读专业型书籍如经济政治学科，我们可能需要带着很多的问题来辅助阅读。例如：&lt;/p>
&lt;ul>
&lt;li>这本书在谈些什么？&lt;/li>
&lt;li>这本书的意义和内容？&lt;/li>
&lt;li>作者的目的？&lt;/li>
&lt;li>本书的内容真实吗？&lt;/li>
&lt;li>你对本书的观点在观看前后变化大吗？是否会进行调整？&lt;/li>
&lt;li>最后感觉本书哪里说的对？哪里说的有缺陷？&lt;/li>
&lt;/ul>
&lt;p>这是因为一些专业的书籍需要我们对其主题进行归纳和总结，并进行后续的对比和分析。&lt;/p>
&lt;p>但如果你观看的是想象文学或者故事书籍，那么上述的关注点则毫无意义。因为在想象文学中，可能要注意的是不抗拒故事带来想象和影响力，更不需要去找共识、主旨、或者论述，如果你用适于传递知识、与真理一致的标准来看待小说，那么你将收获不到作者想带给你的任何共鸣。&lt;/p>
&lt;h3 id="分层阅读">分层阅读&lt;/h3>
&lt;p>除了需要关注分类的阅读方法外，对于部分书籍和资料还需要进行分层阅读，根据自身的水平选择合适难度的书，例如：&lt;/p>
&lt;ul>
&lt;li>入门类：激发个人兴趣，了解某领域的大致范围和概念。以帮助自身了解是否对该主题感兴趣，是否继续研究？&lt;/li>
&lt;li>精通类：某领域中的基础教科书、通识书，需要有完整的体系结构。&lt;/li>
&lt;li>专业类：已经对整个领域有相当的了解，对领域的某一个方向、流派进行定向、延展阅读。&lt;/li>
&lt;li>先驱类：不过多解释，超出笔者能力范畴太多，书籍的实效性大概率已经满足不了你了，去研究论文吧。&lt;/li>
&lt;/ul>
&lt;p>需要进行分层阅读的大多数都是专业书籍，关于这点笔者唯一要提醒的是，在入门级别以上，例如构建完整的领域知识体系，尽量选择国外的教科书，看看这个专业最好的学校使用的教科书是哪本，你可以通过 &lt;a href="https://galaxy.opensyllabus.org/">Open Syllabus Project&lt;/a> 来搜索顶级大学常用教材，以免被不称职的教科书毁掉你的兴趣。&lt;/p>
&lt;p>相信笔者，如果你阅读某领域的入门和精通级别的书籍读不下去，那不是你的问题，而是作者的问题。&lt;/p>
&lt;h2 id="知行合一">知行合一&lt;/h2>
&lt;blockquote>
&lt;p>把学到的东西藏在心里不仅是可耻的，而且是有害的，凡是我们不去努力分享的，也必将从我们这里失去。&lt;/p>
&lt;/blockquote>
&lt;p>每当阅读完一本书后，笔者一开始总是沾沾自喜，自认为又掌握了很多知识。直到随着时间的推移，记忆的模糊，不得不悲观的承认，知识不会永远属于我。于是笔者努力探索方法将知识保留的久一点。包括但不限于这些方法：&lt;/p>
&lt;ul>
&lt;li>主动阅读：向书本和作者提出自己的疑问。
&lt;ul>
&lt;li>本书在谈些什么？ 是如何依次发展主题的，如何逐步从核心主题分解出从属的关键议题来。&lt;/li>
&lt;li>作者要表达什么？找出主要的想法、声明与论点。组合成作者想要传达的特殊讯息。&lt;/li>
&lt;li>本书说得有道理吗？是全部有道理，还是部分有道理？&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>记录笔记：
&lt;ul>
&lt;li>列出大纲和重要观点。&lt;/li>
&lt;li>回答上述主动阅读的问题。&lt;/li>
&lt;li>相同主题书籍之间的关联，不同作者对同一个问题的看法。&lt;/li>
&lt;li>作者和自己的看法。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>那么经过上述的努力后，知识就属于自己了吗？笔者不得不绝望的承认，知识的失去可能有所减缓，但是仍然在不可逆转的持续。&lt;/p>
&lt;p>并且在做笔记的过程中，写的满满当当的笔记会让我自己不承认自己的无知和浅薄，会认为自己写下的笔记，就是已经收获的知识，而笔记滋生出的优越感将自己慢慢带向自欺与虚荣。&lt;/p>
&lt;p>随着时间的推移，笔者发现可能只有靠分享知识，靠教导他人，才能在某种程度上解决该问题。&lt;/p>
&lt;p>只有当笔者分享时出现语塞词穷的情况，才会正视自己的无知。只有在分享知识而不能自圆其说之时，才会认识到自己的偏见。而这种窘迫能帮助自己摆脱无知和偏见，以谦虚的心态去学习知识。&lt;/p>
&lt;p>所以可能只有通过输出分享，以教代学的方式才能正视无知与浅薄。甚至只有通过实际的行动知行合一，才能将知识完整掌握。&lt;/p>
&lt;p>那么我们该如何分享呢？身边有朋友进行分享讨论和争辩的话绝对是人生一大幸事，没有的话也无需在意，在互联网时代我们可以通过发表文章，例如发表到自己的博客或者网络平台上。也可以通过制作视频、举办 session 的方式来扩展，借此来找到更多志同道合的朋友。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>回顾上面所有内容，我们从主题阅读的需要，而衍生了一些的流程来辅助阅读。然而所有的工具和流程都只能作为辅助手段，切记不可因小失大，忘记初衷而陷入工具的漩涡中无法自拔。&lt;/p>
&lt;p>阅读方法论唯一有价值的就是阅读本身，多阅读一本书的内容本身，比起将时间花费在阅读工具、方式和流程要来的更加有价值。&lt;/p>
&lt;p>世界上也不存在所有人通用的阅读方法，阅读方法本身就代表着强烈的个性和说教，如果你有更好或更适合你的方法，可以在评论中互相探讨。&lt;/p>
&lt;p>本文撰写于颠覆性生产力变革的前夜，OpenAI 刚刚发布 GPT-4 的模型。纵观工业革命以来的近代史，我们可能身处蒸汽机或信息技术变革的前夜，随着生产力的变革，社会动荡往往也会加剧，通胀、失业、战争都是这个康波周期底部的产物。而越是困难时期，阅读和思考就愈发显得弥足珍贵。毕竟 AI 唯一替代不了的，就是思考本身。&lt;/p>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://sspai.com/post/78133">https://sspai.com/post/78133&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://book.douban.com/top250">https://book.douban.com/top250&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://galaxy.opensyllabus.org/">https://galaxy.opensyllabus.org/&lt;/a>&lt;/li>
&lt;li>《如何阅读一本书》&lt;/li>
&lt;/ol></description></item><item><title>日志的艺术</title><link>https://guangzhengli.com/blog/zh/the-art-of-logging/</link><pubDate>Tue, 28 Feb 2023 20:33:36 +0800</pubDate><author>iguangzhengli@gmail.com (Guangzheng Li)</author><guid>https://guangzhengli.com/blog/zh/the-art-of-logging/</guid><description>&lt;p>理解日志并不是一件容易的事，开发人员在编写代码之时往往会纠结在某处打印的日志是不是有意义的，而 SRE 在面对缺少日志的生产问题时往往一筹莫展，Ops 在对面海量日志时往往需要花费更多的精力来维护，而项目的实际管理者在面对毫无实际业务价值的日志时，往往不想花费太多的人力和财力去管理它。&lt;/p>
&lt;p>因此，在开发应用程序时遵循良好的实践，在收集管理日志时选用成熟的方案，往往能让这些矛盾得以缓解，这也就有了这一篇的分享。&lt;/p>
&lt;h2 id="矛盾的开始">矛盾的开始&lt;/h2>
&lt;p>首先介绍的是为什么需要记录日志，日志的作用。其实关于日志的作用无需介绍太多，因为大多数的开发人员在调试代码问题时，解决不同环境的 Bug 时都有很明确的感受以及强烈的需求。日志作为调试的助手，生产环境的救星。笔者只见过嫌弃日志打的太少的，几乎没有见过嫌弃日志打的太多的开发和运维人员。通过查询日志的方式来确定代码的分支走向，API是否请求正确，核心业务的数据是否正确，是否有错误的堆栈信息，这些都构成开发和运维人员判断代码和生产问题的第一手段。笔者难以想象如果一个复杂庞大的系统没有记录任何日志，该如何排查生产环境的 Bug。&lt;/p>
&lt;p>如果有如此强烈的需求，那每一行代码都打日志来记录上下文不就行了吗？这样无论什么环境有什么代码有问题，通过搜索日志都可以排查出来。理论上这样确实可行，但是有一些问题目前无法解决，一是日志存储量的问题，常见的中大型系统日志大概在 TB 级，超大型系统的日志大概在 PB 级，根据 &lt;a href="https://blog.cloudflare.com/log-analytics-using-clickhouse/">Cloudflare提供的数据&lt;/a>，它每秒大概处理 4 千万的请求，这对于存储的费用来讲是一个巨大的挑战。二是搜索的性能下降，像 &lt;a href="https://github.com/elastic/elasticsearch">Elasticsearch&lt;/a> 数据库这类常见的日志存储方案，海量的日志会导致其所维护的映射关系爆炸式增长，即使划分不同的 Index，分布式管理不同的 ElasticSearch 集群，也很难做到搜索性能不随数据量的增加而下降。三是海量日志的生成会在峰期时拖慢系统性能，增大出故障的风险。&lt;/p>
&lt;p>所以综上可以得出最简单的结论，即日志既不能打印太多导致存储和管理日志太难，也不应该因为打印太少导致运维人员无法排查问题，这听起来自相矛盾，但这就是关于日志的艺术！&lt;/p>
&lt;h2 id="日志级别">日志级别&lt;/h2>
&lt;p>通常在我们打算记录日志前，我们需要判断打印日志的级别，在介绍如何确定日志级别前，我们先聊一聊日志级别的作用。首先第一点是大家所熟知的，日志级别可以帮助确定日志信息的优先级，可以有效的减少信息噪音和警报疲劳。二是在查询日志时，加到日志级别的过滤，能有效的查询到所需的日志。&lt;/p>
&lt;p>常见的日志级别有以下几类，并且从低到高的顺序是：&lt;code>TRACE&lt;/code>、&lt;code>DEBUG&lt;/code> 、&lt;code>INFO&lt;/code>、 &lt;code>WARN&lt;/code>、&lt;code>ERROR&lt;/code>、 &lt;code>FATAL&lt;/code>。通常在本地环境，我们打印日志所配置的级别是 &lt;code>Trace&lt;/code> ，即打印出所有级别的日志，但是在生产环境，会随着存储的压力，查询的性能和磁盘 IO 的影响，将日志的级别调整到 &lt;code>INFO&lt;/code> 级别甚至是 &lt;code>ERROR&lt;/code> 级别。这就意味着你在代码中低于该级别的日志都不会打印。&lt;/p>
&lt;p>那这是不是代表我们在代码中只需要打印和生产环境匹配的日志级别呢？例如生产环境只打印 &lt;code>INFO&lt;/code> 级别的日志，我们在代码中写 &lt;code>DEBUG&lt;/code> 级别的日志并不会打印，也没有必要写了。有的项目管理者为了省下日志管理的费用，只在生产环境只打印 &lt;code>ERROR&lt;/code> 级别的日志，那是不是 &lt;code>INFO&lt;/code> 级别的日志也可以不写呢？代码中只打印和生产环境匹配的日志级别日志，这确实是笔者在大多数项目时看到的现状，但是现实情况也往往更加复杂，例如以下几个场景。&lt;/p>
&lt;h3 id="场景一">场景一&lt;/h3>
&lt;p>某工程师在调查生产环境中某个创建资源的 API 性能较低问题时，发现是由于该 API 在保存资源前做了写 &lt;code>INFO&lt;/code> 级别的日志，将资源对象都写到日志中，由于资源的对象属性很多，所以导致在业务峰期时，代码打印出海量日志，耗尽Buffer区内存，从而拖慢主线程，造成服务性能整体下降。因此该工程师将该业务日志打印操作删除，以降低生产环境磁盘 IO 损耗，解决性能问题。&lt;/p>
&lt;p>但是某天由于修改了该 API 服务调用链路上的某服务代码，导致该 API 创建出来的对象有错误，并且由于缺少了生产环境保存该资源时的日志，无法排查出是 API 的请求参数有问题，还是后续的计算逻辑有问题。这时我们只能重新修改日志级别，重新构建发布上线吗？&lt;/p>
&lt;h3 id="场景二">场景二&lt;/h3>
&lt;p>假设将生产环境的日志设置为 &lt;code>ERROR&lt;/code> 级别。某一时刻，依赖的下游服务故障，导致请求大量超时。又由于在业务峰期 QPS 非常高的时期，短时间内集中产生大量的错误日志，导致磁盘IO急剧提高，耗费大量CPU，进而导致整个服务瘫痪。我们应该如何处理？&lt;/p>
&lt;h3 id="场景三">场景三&lt;/h3>
&lt;p>某工程师在排查生产问题时，发现 &lt;code>INFO&lt;/code> 级别的日志还无法满足排查 Root Cause，有一个 &lt;code>DEBUG&lt;/code> 日志级别的日志是他需要的，但是生产环境只有 &lt;code>INFO&lt;/code> 级别，这时只能修改级别然后重新启动服务吗？&lt;/p>
&lt;h3 id="日志级别规范与动态调整">日志级别规范与动态调整&lt;/h3>
&lt;p>解决以上问题的方法，一是需要我们在项目中，明确日志级别的规范，不为了调试方便和减少存储随意使用日志级别。二是给日志级别加上&lt;strong>动态调整&lt;/strong>的功能。也就是需要解决线上问题时，调低线上日志输出级别，获取全面的Debug日志，帮助工程师提高定位问题的效率。在生产日志海量增加拖慢服务性能时，调高线上日志输出级别，减少日志的生成，缓解磁盘 IO 压力和提高服务性能。&lt;/p>
&lt;p>以下是对于日志级别给出的建议：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>TRACE：应该在开发期间使用它来追踪错误，但永远不要提交到版本控制系统（VCS）中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DEBUG：记录程序中发生的任何事情。主要在调试期间使用，建议在进入生产阶段之前缩减调试语句的数量，只留下最有意义的条目，并可以在故障排除期间激活。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>INFO：记录所有由用户驱动的事件或特定于系统的操作（例如定期计划操作）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>WARN：此级别记录所有可能成为错误的事件。例如，如果一个数据库调用花费的时间超过预定义的时间，或者如果内存缓存接近容量。这将允许适当的自动警报，并在故障排除期间允许更好地了解系统在故障之前的行为方式。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ERROR：在此级别记录每个错误条件。这可以是返回错误或内部错误条件的 API 调用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>FATAL：代表整个服务已经无法工作。请非常节制地使用这个级别。通常此级别记录表示程序的结束。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="记录日志">记录日志&lt;/h2>
&lt;h3 id="什么时候记录日志">什么时候记录日志&lt;/h3>
&lt;p>什么时候记录日志并没有标准规范，需要开发人员根据业务和代码来自行判断，除了常规的记录事件，例如进行了哪些操作、发生了与预期不符的情况、运行期间出现未能处理的异常或警告、定期自动执行的任务外。笔者还建议在以下场景加上日志：&lt;/p>
&lt;ul>
&lt;li>在调用第三方系统时，将调用 API 的 URL 带上 &lt;code>Request/Response Body&lt;/code> 和异常都记录到日志。原因是当发生故障时，能够有明确且清晰的的日志报告说明故障原因，减少不同系统服务运维人员或者不同公司之间的&lt;strong>责任界定&lt;/strong>，以更顺畅的方式推动问题的解决。&lt;/li>
&lt;li>在重要核心业务的关键代码和分支加上日志，例如 if-then-else 语句，它可以帮助开发人员了解程序是否根据其当前状态遍历了预期路径。并且由于核心业务的数据普遍难以手动复现，了解代码分支的走向至关重要。&lt;/li>
&lt;li>核心业务的审计日志，如果某业务和法律或合同具有关联性，给对应的操作加上审计日志是非常有必要的。并且存储日志要求强一致性数据库。&lt;/li>
&lt;li>应用服务启动时输出配置信息。初始化配置的逻辑一般只会执行一次，不便于诊断时复现，所以应该输出到日志中。&lt;/li>
&lt;/ul>
&lt;h3 id="日志属性">日志属性&lt;/h3>
&lt;p>除了在日志常规需要打印的 &lt;code>log level&lt;/code>，&lt;code>timestamp&lt;/code>，&lt;code>message&lt;/code>，&lt;code>exception&lt;/code> 和 &lt;code>stack trace&lt;/code> 外，排查问题往往还需要其它的字段来帮助定位和查找 Root Cause，常见的额外字段有以下几种：&lt;/p>
&lt;ul>
&lt;li>&lt;code>trace id&lt;/code> 即服务链路追踪的唯一 ID。在请求进入到系统 7 层网关时，即在 HTTP header 中加上对应请求整个生命周期唯一的 &lt;code>trace id&lt;/code>，并随着该请求调用一直携带。当请求链路过长，开发人员难以找到完整的请求日志时，&lt;code>trace id&lt;/code> 有助于反向查找完整日志。&lt;/li>
&lt;li>&lt;code>span id&lt;/code> 即表示 &lt;code>trac id&lt;/code> 生命周期中拆分的单个操作。例如当请求到达每个服务后，服务都会为请求生成 spanid，第一个 spanid 称之为 root span，而随请求一起从上游传过来的 spanid 会被记录成 pspanid (parent-spanid)。当前服务生成的 spanid 随着请求一起再传到下游服务时，这个spanid 又会被下游服务当做 pspanid 记录。由此 &lt;code>span id&lt;/code> 有助于当服务调用复杂时还原出整个请求的调用链路视图。&lt;/li>
&lt;li>&lt;code>user id&lt;/code> 即用户的唯一 ID。确保当用户上报 Issue 或者提交 TIcket 的时候，可以根据当前用户的唯一 ID 直接查询对应错误日志，减少干扰项，缩短排查周期。&lt;/li>
&lt;li>&lt;code>tenant_id&lt;/code> 这是租户 ID（如果存在）。对多租户系统非常有帮助&lt;/li>
&lt;li>&lt;code>request uri&lt;/code> 即当前微服务请求 URI (用户一个业务操作可能对应着多个服务不同的 &lt;code>request uri&lt;/code>)，当某业务出现问题时，通过该业务对应&lt;strong>入口&lt;/strong>的 &lt;code>request uri&lt;/code> 往往能很快拿到 &lt;code>trac id&lt;/code>，再通过 &lt;code>trac id&lt;/code> 去查找对应请求的日志往往能很快解决问题。&lt;/li>
&lt;li>&lt;code>application name&lt;/code> 即当前微服务名称。有助于识别哪个服务生成了此日志，也有助于通过 &lt;code>application name&lt;/code> 过滤日志，查询服务整体故障。&lt;/li>
&lt;li>&lt;code>pod name&lt;/code> 即当前请求所在的 k8s 资源 Pod 名称（如果存在）。目前大多数微服务使用 k8s 来完成容器编排，打印 &lt;code>pod name&lt;/code> 有助于当某个 &lt;code>pod&lt;/code> 故障时，重启或者 Kill Pod。&lt;/li>
&lt;li>&lt;code>host name&lt;/code> 即当前请求所在的机器名称。即使使用 k8s 托管微服务，也会出现由于 k8s 集群所在的某台机器出现磁盘或者网络故障时，服务无法正常工作的情况，打印 &lt;code>host name&lt;/code> 有助于排查问题最后一公里，即由于机器硬件问题导致故障。&lt;/li>
&lt;/ul>
&lt;h3 id="日志安全">日志安全&lt;/h3>
&lt;p>日志需要保证日志框架的安全和敏感信息处理。框架安全指的是使用成熟的，经过大量生产环境验证的日志框架库，而非自己造轮子。敏感信息处理是大部分公司的生命线，请牢记日志的安全性和合规性要求：&lt;/p>
&lt;ul>
&lt;li>不要泄露敏感的个人身份信息 (PII)。&lt;/li>
&lt;li>不要泄露加密密钥或秘密。&lt;/li>
&lt;li>确保公司的隐私政策涵盖日志数据。&lt;/li>
&lt;li>确保日志提供商满足合规性需求。&lt;/li>
&lt;li>确保满足数据存储时间要求。&lt;/li>
&lt;/ul>
&lt;h3 id="日志的坏味道">日志的坏味道&lt;/h3>
&lt;ul>
&lt;li>使用中文或者非英文打印日志。
&lt;ul>
&lt;li>英文表示日志将以 ASCII 字符记录。这一点特别重要，因为像中文经过一系列处理后，它可能因为字符集或者编码集最终无法正确呈现。&lt;/li>
&lt;li>英文自带分词效果，像使用 &lt;code>ElasticSearch&lt;/code> 这类倒排索引存储引擎存储日志，中文日志不仅需要添加专门的分词器，并且存储和查询效果不如英文。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>没有上下文的日志。类似直接打印 &lt;code>Transaction failed&lt;/code> 或者 &lt;code>User operation succeeds&lt;/code> 这类日志。因为在写代码时通过代码上下文能够理解日志消息，但是当阅读日志本身时，这个上下文不存在，这些消息可能无法理解。&lt;/li>
&lt;li>将打印日志的操作放在循环当中。除非特定需求，否则打印出来的日志不仅难以阅读和查找，还会耗费大量存储资源。&lt;/li>
&lt;li>引用慢操作数据，如果当前上下文中没有打印日志需要的数据，需要调用远程服务或者从数据库获取，又或者通过大量计算，那应该先考虑这项信息放到日志中是不是必要且恰当的。&lt;/li>
&lt;/ul>
&lt;h2 id="日志的可观测性">日志的可观测性&lt;/h2>
&lt;p>最近十年因为微服务和云原生的相继崛起，收集存储和分析日志领域发生了重大的变化。早期我们无需进行日志的收集，当时将单体服务的所有日志存储在文件当中，使用 tail、grep、awk 来从日志中挖掘信息。但是在系统日益复杂的今天，这种方式已经无法满足我们的需求。为了应对日益复杂的日志管理需求，开源社区和工业界也发展出一些列的方案，例如最为流行的 &lt;a href="https://www.elastic.co/elastic-stack/">Elastic Stack&lt;/a> 开源解决方案，云厂商提供的一站式解决方案像 &lt;a href="https://www.datadoghq.com/product/log-management/">AWS DataDog&lt;/a> 和 &lt;a href="https://www.dynatrace.com/monitoring/platform/log-management-analytics/">Azure Dynatrace&lt;/a>。&lt;/p>
&lt;p>无论使用哪种方案，日志管理都已经不再是一个简单的话题。在我们有明确感知的打印日志和查询分析日志之间，还包含着对日志进行收集、缓冲、聚合、加工、索引、存储等若干个步骤，并且每一步都蕴含着艰难曲折。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/azaofU.jpg" alt="azaofU">&lt;/p>
&lt;h3 id="日志的收集">日志的收集&lt;/h3>
&lt;p>最早我们使用 &lt;a href="https://www.elastic.co/elastic-stack/">Elastic Stack&lt;/a> 中的 &lt;a href="https://www.elastic.co/logstash/">Logstash&lt;/a> 来进行日志的收集和加工。系统中不同的服务通过使用 tcp/udp 的协议，主动发送请求将日志推送到 Logstash 中，接着 Logstash 将日志进行转换加工(数据结构化)和输出。这种模式维持了很长一段时间，但是它也有比较严重的缺陷，那就是 Logstash 与它的插件是基于 JRuby 编写的，要跑在单独的 Java 虚拟机进程上，默认的堆大小就到了 1GB。如果需要部署成千上万个日志收集器，那么这种方案就显得太过沉重。所以后来 Elastic.co 公司使用 Golang 重写了一个功能较少，却更轻量高效的日志收集器 &lt;a href="https://github.com/elastic/beats/tree/master/filebeat">Filebeat&lt;/a> 才缓解了这一矛盾。&lt;/p>
&lt;p>除此之外 &lt;a href="https://github.com/fluent/fluentd">Fluentd&lt;/a> 通常是配合 Kubernetes 时的首选开源日志收集器。它是 Kubernetes 原生的，可以使用 DaemonSet 的方式部署与 Kubernetes 无缝集成。它允许从不同的地方像 Kubernetes 集群、MySQL、Apache2 等收集日志，并解析发送到所需位置如 Elasticsearch、Amazon S3 等。Fluentd 用 Ruby 编写的，在低容量下运行良好，但当需要增加节点和应用程序的数量时，也会有会性能问题。&lt;/p>
&lt;p>最后在日志收集时，有可能会因为业务峰期生成海量日志，影响服务稳定性和造成日志丢失。在这种情况下，我们还需要在 Logstash 或者存储日志数据库前加上一道缓冲层。在较小规模的系统中 &lt;a href="https://redis.io/topics/streams-intro/">Redis streams&lt;/a> 是一个较好的选择，如果面对的规模更大的数据，那么 Kafka 集群或者云厂商提供的消息队列解决方案将是不二之选。&lt;/p>
&lt;h3 id="结构化日志">结构化日志&lt;/h3>
&lt;p>在收集完日志后，我们还需要进行结构化的处理。因为日志是非结构化数据，一行日志中通常会包含多项信息，如果不做处理，那只能以全文检索的原始方式去使用日志，这样既不利于统计对比，也不利于条件过滤。像下面这一行是 Nginx 服务器的 Access Log。&lt;/p>
&lt;pre tabindex="0">&lt;code>10.209.21.28 - - [04/Mar/2023:18:12:11 +0800] &amp;#34;GET /index.html HTTP/1.1&amp;#34; 200 1314 &amp;#34;https://guangzhengli.com&amp;#34; Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36
&lt;/code>&lt;/pre>&lt;p>尽管我们已经习惯了默认的 Nginx 格式，但上面的示例仍然难以阅读和处理。我们可以通过 Logstash 或者其它工具将它转换成结构化的数据，例如 JSON 格式。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;RemoteIp&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;10.209.21.28&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;RemoteUser&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">null&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Datetime&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;04/Mar/2023:10:49:21 +0800&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Method&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;GET&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;URL&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/index.html&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Protocol&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;HTTP/1.1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Status&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">200&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Size&amp;#34;&lt;/span>: &lt;span style="color:#ae81ff">1314&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Refer&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;https://guangzhengli.com&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;Agent&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>经过结构化后，例如像 ElasticSearch 这类倒排索引数据库可以针对不同的数据项建立索引，进行查询统计、聚合等操作。&lt;/p>
&lt;p>除此之外还有一种工业界的做法像 &lt;a href="https://dev.splunk.com/enterprise/docs/developapps/addsupport/logging/loggingbestpractices/">Splunk&lt;/a> 推荐将字段变为 key-value 对的形式放在同一个大的规范日志行中(logfmt)，如将 Nginx 日志作为规范日志行将变成如下这样：&lt;/p>
&lt;pre tabindex="0">&lt;code>remote-ip=10.209.21.28 remote-user=null datetime=&amp;#34;04/Mar/2023:10:49:21 +0800&amp;#34; method=GET url=https://guangzhengli.com/index.html protocol=HTTP/1.1 status=200 size=1314 refer=https://guangzhengli.com agent=&amp;#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36&amp;#34;
&lt;/code>&lt;/pre>&lt;p>这类数据经过 Splunk 存储后，可以通过使用内置的查询语言进行检索，像使用 &lt;code>method=get status=500&lt;/code> 查询所有返回 500 响应的 GET 方法。使用 &lt;code>method=get method=get status=500 earliest=-7d | timechart count&lt;/code> 查询语句得到过去 7 天返回 500 响应的 GET 方法总数量和图表。这种方式笔者使用的并不多，所以感兴趣的可以参考 &lt;a href="https://stripe.com/blog/canonical-log-lines">Stripe canonical-log-lines&lt;/a> 这篇文章获得更多细节。&lt;/p>
&lt;h3 id="日志的存储与查询">日志的存储与查询&lt;/h3>
&lt;p>经过日志的数据结构化后，可以将数据存入数据库中并进行查询分析。在选择使用什么方案来存储和分析之前，我们先来看看日志数据的特点。&lt;/p>
&lt;ul>
&lt;li>日志是写入密集型的，超过 99% 的日志写入后不会被查询使用。&lt;/li>
&lt;li>日志是标准的时间流数据，需要顺序写入，存储到数据库后，不会再进行修改变动。&lt;/li>
&lt;li>日志是具有时效性的，一般只需要最近一段时间的日志来查询分析或者排查故障，一段时间以后会被保留策略清除或者归档。&lt;/li>
&lt;li>日志是半结构化的，尽管我们将所有应用服务的日志都进行结构化，还是还包含系统日志，网络日志等日志，它们字段各不相同。&lt;/li>
&lt;li>查询日志依赖全文检索和即席查询（Ad-hoc search）。&lt;/li>
&lt;li>查询日志不要求日志具有强时效性，但是也无法接受按小时甚至按天的延时。&lt;/li>
&lt;/ul>
&lt;p>基于以上的存储和查询需求 &lt;a href="https://github.com/elastic/elasticsearch">Elasticsearch&lt;/a> 在日志存储领域一骑绝尘，Elasticsearch 可以使用时间范围作为索引，例如根据实际数据量以按日索引的话，由于能准确地预知明天、后天的日期，因此全部索引都可以预先创建，这免去了动态创建的寻找节点、创建分片、在集群中广播变动信息等开销。其次 Elasticsearch 可以针对不同时间范围的数据，进行冷热数据处理，针对最近一段时间的日志数据，在硬件中搭配 SSD 和更强的处理器，针对时间更久的数据，可以使用 HDD 存储或者 AWS S3 进行归档。&lt;/p>
&lt;p>最重要的是 Elasticsearch 的核心存储引擎使用倒排索引天生适配全文检索，并且与其搭配的 Kibana(只负责图形界面和展示) 可以完美适配数据检索、聚合、统计和定制形成各种图形、表格。下图为 &lt;a href="https://www.elastic.co/elastic-stack/">Elastic Stack&lt;/a> 官方图片：&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/nWzzSw.jpg" alt="nWzzSw">&lt;/p>
&lt;p>当然 Elasticsearch 也不是没有缺陷的，Mapping Explosion 就是 Elasticsearch 已知的缺陷之一，Elasticsearch 维护着一个文档 (document) 和字段 (fields) 的映射表，当这个映射表拥有太多的 key 时，会占用大量的内存，导致频繁的垃圾回收。还有它的次冷热分层存储也有其缺陷之处，Elasticsearch 每天都会将数据从热存储移动到冷存储，这也会影响集群的读写性能。&lt;/p>
&lt;p>所以 Elasticsearch 对于一些中小型集群和全文检索有很好的支持，但是对于超大型集群和面向分析的场景，使用面向列的数据库 ClickHouse 可能会是一个更好的选择。日志的不可变性完美的适合 ClickHouse 的存储和分析能力，搭配 ClickHouse 压缩编解码器可以大幅度减少存储需求，其线性可扩展性可以轻松扩展集群。关于更多使用 ClickHouse 存储日志可以看这篇文章：&lt;a href="https://blog.cloudflare.com/log-analytics-using-clickhouse/">Log analytics using ClickHouse&lt;/a>。商业开源公司 &lt;a href="https://signoz.io/blog/opentelemetry-logs/">Signoz&lt;/a> 也将 ClickHouse 作为其 OpenTelemetry 实现方案。下图展示的即 Signoz 的&lt;a href="https://www.splunk.com/en_us/blog/learn/splunk-log-observer.html">实时日志分析场景&lt;/a>。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/8fYrZD.jpg" alt="8fYrZD">&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>回顾整篇文章，我们主要涵盖了打印日志的最佳实践，管理日志的难题和应对挑战的方案。日志作为系统服务最重要的观测手段之一，其重要性不言而喻。在系统日益复杂的今天，开发和运维人员应遵循良好的日志实践，以此来应对日志管理的挑战。&lt;/p>
&lt;p>由于笔者能力有限，以上内容如果有任何错误或者片面的观点，还请直接指出。如果有补充的地方，欢迎在评论或者&lt;a href="https://github.com/guangzhengli/guangzhengli.github.io">仓库&lt;/a>进行补充，非常感谢！&lt;/p>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://blog.cloudflare.com/log-analytics-using-clickhouse/">https://blog.cloudflare.com/log-analytics-using-clickhouse/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cortex.io/post/best-practices-for-logging-microservices">https://www.cortex.io/post/best-practices-for-logging-microservices&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stripe.com/blog/canonical-log-lines">https://stripe.com/blog/canonical-log-lines&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://messagetemplates.org/">https://messagetemplates.org/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.dataset.com/blog/the-10-commandments-of-logging/">https://www.dataset.com/blog/the-10-commandments-of-logging/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://brandur.org/canonical-log-lines">https://brandur.org/canonical-log-lines&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dev.splunk.com/enterprise/docs/developapps/addsupport/logging/loggingbestpractices/">https://dev.splunk.com/enterprise/docs/developapps/addsupport/logging/loggingbestpractices/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://opentelemetry.io/docs/reference/specification/logs/#log-correlation">https://opentelemetry.io/docs/reference/specification/logs/#log-correlation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://signoz.io/blog/opentelemetry-logs/">https://signoz.io/blog/opentelemetry-logs/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://izsk.me/2021/10/31/OpenTelemetry-Trace/">https://izsk.me/2021/10/31/OpenTelemetry-Trace/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://sematext.com/guides/kubernetes-logging/">https://sematext.com/guides/kubernetes-logging/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.datadoghq.com/product/log-management/">https://www.datadoghq.com/product/log-management/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.dynatrace.com/monitoring/platform/log-management-analytics/">https://www.dynatrace.com/monitoring/platform/log-management-analytics/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tech.meituan.com/2017/02/17/change-log-level.html">https://tech.meituan.com/2017/02/17/change-log-level.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://icyfenix.cn/distribution/observability/logging.html">http://icyfenix.cn/distribution/observability/logging.html&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>用 serverless 开发一个 Chat 机器人提醒</title><link>https://guangzhengli.com/blog/zh/webhook-with-serverless/</link><pubDate>Mon, 19 Dec 2022 00:00:00 +0000</pubDate><author>iguangzhengli@gmail.com (Guangzheng Li)</author><guid>https://guangzhengli.com/blog/zh/webhook-with-serverless/</guid><description>&lt;p>本文描述了笔者基于 Serverless 技术开发 Chat 机器人提醒应用的全流程，记录了开发遇到的一些问题和技术选择的思考。在开发完成后，有小伙伴想知道一些技术细节来做二次开发，于是有了这篇分享。&lt;/p>
&lt;h2 id="业务需求">业务需求&lt;/h2>
&lt;p>最开始想开发一个 Chat 机器人提醒，是因为当时项目上的人很多，每天都需要轮换站会和 Code Review 的 Owner，导致每天的站会和 Code Review 时，都需要先花费几分钟时间确认今天的站会 Owner 是谁，接着确定后还要准备 Share 屏幕，最后还需要手动维护项目人员轮换名单，会议的体验很差。为了解决以下的常规会议的痛点：&lt;/p>
&lt;ul>
&lt;li>杜绝会议开始时常见的灵魂问题，今天的 owner 是谁&lt;/li>
&lt;li>缩短会议的准备时间，预防 owner 没有提前去会议室准备的情况&lt;/li>
&lt;li>预防到时间后，有人忘记参加会议，需要人手动提醒&lt;/li>
&lt;/ul>
&lt;p>所以有了第一个想法💡，即做一个自动提醒的机器人，包括有如下功能来缓解痛点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>定时发送消息&lt;/p>
&lt;ul>
&lt;li>在工作日时，在会议开始前5分钟时，发送提醒文本。&lt;/li>
&lt;li>在周末，不发送消息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>当发送文本消息时，文本包括会议地址，owner，和会议时间。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>定时轮换 owner 名单，定时可配置，例如每天轮换，或者每周轮换。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>例如站会的提醒效果图如下所示：&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/screenshotr_2023-2-19T17-12-28.png" alt="screenshotr_2023-2-19T17-12-28">&lt;/p>
&lt;h2 id="技术选型">技术选型&lt;/h2>
&lt;p>在业务需求确定后，首先需要判断系统是否要求高可用、可扩展或者性能是否有要求。在这个用例中，这些技术要求都可以不要，毕竟只是自用的辅助手段，就算偶尔挂了也无所谓。这也为后续的技术选型打开了道路。&lt;/p>
&lt;p>其次需要预估该功能的资源需求，该功能每天定时发送的请求给 Chat 一般不超过 10 条，所以假设 &lt;code>Request / Day = 10&lt;/code>。存储的话需要存储会议的轮换名单，名字占用很少，所以预估最大就是 1KB &lt;code>Size of storage = 1KB&lt;/code>。&lt;/p>
&lt;p>得到技术需求和资源预估后，就能在后续技术选型时有比较明确的方向。首先列出几个可以完成这个功能的方案：&lt;/p>
&lt;ul>
&lt;li>Local machine + Disk&lt;/li>
&lt;li>Cloud VM + Disk&lt;/li>
&lt;li>Serverless
&lt;ul>
&lt;li>AWS Lambda + DynamoDB&lt;/li>
&lt;li>Azure Function + CosmosDB&lt;/li>
&lt;li>Cloudflare Worker + Worker KV&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="local-machine--disk">Local machine &amp;amp; Disk&lt;/h2>
&lt;p>首先我们尝试使用 Python 或者任意语言在本地环境进行 Schedule 定时，直接使用本地环境进行部署运行，因为不要求高可用，偶尔的服务宕机可以接受，所以在追求最简单的方式来实现也未尝不可。&lt;/p>
&lt;p>方案是使用 Python schedule 库或者任意语言定时发送消息，使用本地文件来存储轮换名单。优点是在本地部署调试和管理起来比较方便，不需要额外的花费，缺点是必须保证 Python 定时进程存活和网络可用，一旦电脑关机或者你请假时就不可用了🤔。如下代码 Demo 是从同目录下 &lt;code>code_review.txt&lt;/code> 文件中拿到当前会议 Owner 名字和下一个 Owner 的名字，一起发送 Code Review 提醒给企业微信。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> posixpath &lt;span style="color:#f92672">import&lt;/span> split
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> corpwechatbot.chatbot &lt;span style="color:#f92672">import&lt;/span> CorpWechatBot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> schedule
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> time
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> datetime &lt;span style="color:#f92672">import&lt;/span> datetime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>message &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;Code Review马上开始啦
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">-----------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">ZOOM URL: https://xxx.zoom.us/j/xxx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> ID: xxx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> Passcode: xxx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">-----------------------------
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">今天的 host 是: &lt;/span>&lt;span style="color:#e6db74">{current_owner}&lt;/span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">明天的 host 是: &lt;/span>&lt;span style="color:#e6db74">{next_owner}&lt;/span>&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">get_code_review_owner_name&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f &lt;span style="color:#f92672">=&lt;/span> open(&lt;span style="color:#e6db74">&amp;#39;code_review.txt&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;r&amp;#39;&lt;/span>, encoding&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;utf-8&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name_array &lt;span style="color:#f92672">=&lt;/span> f&lt;span style="color:#f92672">.&lt;/span>read()&lt;span style="color:#f92672">.&lt;/span>split()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current_owner &lt;span style="color:#f92672">=&lt;/span> name_array[&lt;span style="color:#ae81ff">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> next_owner &lt;span style="color:#f92672">=&lt;/span> name_array[&lt;span style="color:#ae81ff">1&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name_array&lt;span style="color:#f92672">.&lt;/span>insert(len(name_array), name_array&lt;span style="color:#f92672">.&lt;/span>pop(&lt;span style="color:#ae81ff">0&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> write_txt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39; &amp;#39;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>join(name_array)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f &lt;span style="color:#f92672">=&lt;/span> open(&lt;span style="color:#e6db74">&amp;#39;code_review.txt&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;w&amp;#39;&lt;/span>, encoding&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;utf-8&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f&lt;span style="color:#f92672">.&lt;/span>write(write_txt)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f&lt;span style="color:#f92672">.&lt;/span>close
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> current_owner, next_owner
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">send_notification&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> current_owner, next_owner &lt;span style="color:#f92672">=&lt;/span> get_code_review_owner_name()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> send_message &lt;span style="color:#f92672">=&lt;/span> message&lt;span style="color:#f92672">.&lt;/span>format(current_owner&lt;span style="color:#f92672">=&lt;/span>current_owner, next_owner&lt;span style="color:#f92672">=&lt;/span>next_owner)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bot &lt;span style="color:#f92672">=&lt;/span> CorpWechatBot(key&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;key providerd by wechat work&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bot&lt;span style="color:#f92672">.&lt;/span>send_text(content&lt;span style="color:#f92672">=&lt;/span>send_message, mentioned_list&lt;span style="color:#f92672">=&lt;/span>[&lt;span style="color:#e6db74">&amp;#39;@all&amp;#39;&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>schedule&lt;span style="color:#f92672">.&lt;/span>every()&lt;span style="color:#f92672">.&lt;/span>monday&lt;span style="color:#f92672">.&lt;/span>at(&lt;span style="color:#e6db74">&amp;#34;17:00&amp;#34;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>do(send_notification)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>schedule&lt;span style="color:#f92672">.&lt;/span>every()&lt;span style="color:#f92672">.&lt;/span>tuesday&lt;span style="color:#f92672">.&lt;/span>at(&lt;span style="color:#e6db74">&amp;#34;17:00&amp;#34;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>do(send_notification)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>schedule&lt;span style="color:#f92672">.&lt;/span>every()&lt;span style="color:#f92672">.&lt;/span>wednesday&lt;span style="color:#f92672">.&lt;/span>at(&lt;span style="color:#e6db74">&amp;#34;17:00&amp;#34;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>do(send_notification)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>schedule&lt;span style="color:#f92672">.&lt;/span>every()&lt;span style="color:#f92672">.&lt;/span>thursday&lt;span style="color:#f92672">.&lt;/span>at(&lt;span style="color:#e6db74">&amp;#34;17:00&amp;#34;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>do(send_notification)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>schedule&lt;span style="color:#f92672">.&lt;/span>every()&lt;span style="color:#f92672">.&lt;/span>friday&lt;span style="color:#f92672">.&lt;/span>at(&lt;span style="color:#e6db74">&amp;#34;17:00&amp;#34;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>do(send_notification)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> schedule&lt;span style="color:#f92672">.&lt;/span>run_pending()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time&lt;span style="color:#f92672">.&lt;/span>sleep(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="cloud-vm--disk">Cloud VM &amp;amp; Disk&lt;/h3>
&lt;p>第二个方案使用云服务器来运行定时进程，和第一个方案使用的技术栈和代码相同，可以用任意语言定时发送消息，只需要注意服务器时区问题即可。区别在于该方案需要购买云服务器来部署，不用在意关机或者不可用问题，但是在目前这种技术需求和资源需求下，去买一个云服务器完成该功能肯定是不划算的。&lt;/p>
&lt;p>以上两种方案都有各自的优缺点，一种是可用性不高，一种是费用高，所以接下来最后一种 Serverless 方案，即是可以解决这两种问题的方案，也是我们今天主要需要讲的方案。&lt;/p>
&lt;h2 id="serverless">Serverless&lt;/h2>
&lt;p>最后一种也是今天主要聊的方案，即使用无服务器计算的方式来完成定时计算，发送消息给 Chat Webhook 服务器。&lt;/p>
&lt;p>无服务器计算（serverless computing），是一种由云服务商（AWS，Azure 或 Cloudflare）负责通过动态分配资源来执行一段代码的执行模型，并且仅收取运行代码所使用资源的费用。该代码通常运行在无状态的容器中，能够被包括HTTP请求、调度事件（cron任务）等各种事件触发并运行。因为代码运行在无状态的容器中，所以无法存储数据，对此云服务商提供了不同类型的存储服务和 SDK，可以无缝衔接对应厂商提供的 Serverless。&lt;/p>
&lt;p>在之前分析技术需求时，我们了解到该应用的 &lt;code>Request / Day &amp;lt; 10&lt;/code>，每天所需的 CPU 时间很少，所以使用 serverless 来执行定时发送消息的任务非常的合适。主要原因一是基础设施由云服务商提供，可用性方面有一定的保证，二是价格非常便宜(这也是 serverless 普及的最重要的原因)。下面是各大云服务商提供的每月免费额度，我们这个项目每个月用不到免费额度的万分之一。&lt;/p>
&lt;ul>
&lt;li>AWS Lamda: 128M + 3,200,000S / 1 month&lt;/li>
&lt;li>Azure Function: 1 million requests / 1 month&lt;/li>
&lt;li>Cloudflare Workers: 100,000 requests / 1 month&lt;/li>
&lt;/ul>
&lt;p>由于 serverless 是不提供存储功能的，所以需要存储人员轮换名单的话，光靠 serverless 的无状态容器就不够用了。需要用到各大云服务商提出的不同类型存储服务，比如有关系型数据库、NoSQL、KV，甚至是基于 SQLite 的 &lt;code>serverless database&lt;/code>，例如 &lt;a href="https://blog.cloudflare.com/introducing-d1/">Cloudflare D1&lt;/a>。回顾我们需要存储的数据，只是简单的团队人员名单，所以无需使用结构化的数据，只需要很简单的 KV 存储即可。如下面几个 KV 服务和其对应的云厂商的免费额度：&lt;/p>
&lt;ul>
&lt;li>AWS DynamoDB：25GB Storage + 1G Networks&lt;/li>
&lt;li>Azure CosmosDB: 1000 request per-second + 25GB storage&lt;/li>
&lt;li>Cloudflare Workers KV: 1GB storage&lt;/li>
&lt;/ul>
&lt;p>由于 Cloudflare 原生提供绑定域名和提供 &lt;code>serverless database&lt;/code>，所以笔者比较喜欢使用 Cloudflare Workers (不过可用性方面个人认为不如 AWS，偶尔会定时无效)。这里就以 Cloudflare Workers 为例展示功能代码，代码主要分为两个 &lt;code>serverless application&lt;/code>，也就是两个定时任务，一是定时发送消息给 Chat 提供的 webhook 地址，另一个是定时轮换主持会议的 owner 名单。&lt;/p>
&lt;p>首先是定时发送消息给 Chat 提供的 webhook 地址，从 KV 中获取当前的会议 Owner，会议地址和消息，通过获取配置的 webhook 地址发送给对应的 Chat（企业微信或者 Google Chat）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">send_google_chat_message&lt;/span> } &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;./google_chat_notificaiton&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">send_wework_chat_message&lt;/span> } &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;./wework_chat_notificaiton&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#a6e22e">scheduled&lt;/span>(&lt;span style="color:#a6e22e">controller&lt;/span>, &lt;span style="color:#a6e22e">env&lt;/span>, &lt;span style="color:#a6e22e">ctx&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">standup_owner_name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#a6e22e">get_owner_name&lt;/span>(&lt;span style="color:#a6e22e">env&lt;/span>, &lt;span style="color:#a6e22e">env&lt;/span>.&lt;span style="color:#a6e22e">KV_STANDUP_OWNER_NAMES&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">`今日的站会马上开始!!!\n今日站会 owner 是: &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">standup_owner_name&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">\n会议地址是: https://zoom.us/j/xxxx`&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">env&lt;/span>.&lt;span style="color:#a6e22e">MESSAGE_TYPE&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;GoogleChat&amp;#39;&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">send_google_chat_message&lt;/span>(&lt;span style="color:#a6e22e">env&lt;/span>, &lt;span style="color:#a6e22e">message&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">env&lt;/span>.&lt;span style="color:#a6e22e">MESSAGE_TYPE&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;WeworkChat&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">send_wework_chat_message&lt;/span>(&lt;span style="color:#a6e22e">env&lt;/span>, &lt;span style="color:#a6e22e">message&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">get_owner_name&lt;/span>(&lt;span style="color:#a6e22e">env&lt;/span>, &lt;span style="color:#a6e22e">type&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">namesString&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#a6e22e">env&lt;/span>.&lt;span style="color:#a6e22e">notification_namespace&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#a6e22e">type&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">names&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">namesString&lt;/span>.&lt;span style="color:#a6e22e">split&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;,&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">names&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>二是定时轮换人员名单，这里主要是因为 owner 人员的轮换和会议主持时间可能不同步，例如每周轮换一次 Owner，明天发送 owner 主持的消息，所以需要单独的一个定时。下面代码实例展示周五发送轮换 owner 的消息。从 KV 中获取下一个 onwer 列表，轮换名单，并且 push 到 KV 中以便后续发送会议消息时拿到 owner 名单。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">send_google_chat_message&lt;/span> } &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;./google_chat_notificaiton&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> { &lt;span style="color:#a6e22e">send_wework_chat_message&lt;/span> } &lt;span style="color:#a6e22e">from&lt;/span> &lt;span style="color:#e6db74">&amp;#34;./wework_chat_notificaiton&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">export&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#a6e22e">scheduled&lt;/span>(&lt;span style="color:#a6e22e">controller&lt;/span>, &lt;span style="color:#a6e22e">env&lt;/span>, &lt;span style="color:#a6e22e">ctx&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">next_standup_owner_name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#a6e22e">getAndRotateOwners&lt;/span>(&lt;span style="color:#a6e22e">env&lt;/span>, &lt;span style="color:#a6e22e">env&lt;/span>.&lt;span style="color:#a6e22e">KV_STANDUP_OWNER_NAMES&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">message&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">`Happy Friday! 别忘记填写 timecard 哦!!!\n下周站会 owner 是: &lt;/span>&lt;span style="color:#e6db74">${&lt;/span>&lt;span style="color:#a6e22e">next_standup_owner_name&lt;/span>&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">env&lt;/span>.&lt;span style="color:#a6e22e">MESSAGE_TYPE&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;GoogleChat&amp;#39;&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">send_google_chat_message&lt;/span>(&lt;span style="color:#a6e22e">env&lt;/span>, &lt;span style="color:#a6e22e">message&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#a6e22e">env&lt;/span>.&lt;span style="color:#a6e22e">MESSAGE_TYPE&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#39;WeworkChat&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">send_wework_chat_message&lt;/span>(&lt;span style="color:#a6e22e">env&lt;/span>, &lt;span style="color:#a6e22e">message&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">getAndRotateOwners&lt;/span>(&lt;span style="color:#a6e22e">env&lt;/span>, &lt;span style="color:#a6e22e">type&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">namesString&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#a6e22e">env&lt;/span>.&lt;span style="color:#a6e22e">notification_namespace&lt;/span>.&lt;span style="color:#a6e22e">get&lt;/span>(&lt;span style="color:#a6e22e">type&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">names&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">namesString&lt;/span>.&lt;span style="color:#a6e22e">split&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;,&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">names&lt;/span>.&lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#a6e22e">names&lt;/span>.&lt;span style="color:#a6e22e">shift&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">storeNameString&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">names&lt;/span>.&lt;span style="color:#a6e22e">join&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;,&amp;#39;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">await&lt;/span> &lt;span style="color:#a6e22e">env&lt;/span>.&lt;span style="color:#a6e22e">notification_namespace&lt;/span>.&lt;span style="color:#a6e22e">put&lt;/span>(&lt;span style="color:#a6e22e">type&lt;/span>, &lt;span style="color:#a6e22e">storeNameString&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">names&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>完整的项目代码放在这个 &lt;a href="https://github.com/guangzhengli/workers-webhook-notification">仓库&lt;/a> 👈&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>回顾整个开发流程，我们能很轻易的感受到 serverless 的易用性和潜力，像类似于 WebHook、数据统计分析、Trigger 及定时任务和 Chat 机器人等功能，借用于 serverless 可以轻易的实现和部署，完成系统的原型设计和想法的闭环。近几年业界也在不断完善 serverless 的开发流程和核心缺陷，例如 &lt;a href="https://www.infoq.com/news/2022/12/aws-lambda-snapstart-accelerate/">JVM 冷启动问题&lt;/a>，&lt;a href="https://docs.aws.amazon.com/lambda/latest/dg/telemetry-api.html">serverless 观测和调试增强&lt;/a>，数据库 serverless 化如&lt;a href="https://github.com/wundergraph/wunderbase">wunderbase&lt;/a>，&lt;a href="https://neon.tech/?utm_campaign=newsletter">Neon&lt;/a>，&lt;a href="https://planetscale.com/">planetscale&lt;/a>，&lt;a href="https://blog.cloudflare.com/introducing-d1/">D1&lt;/a> 等项目。假以时日，当这些问题慢慢解决和优化，serverless 广阔的前景和强大将刷新人们的认知。&lt;/p>
&lt;h2 id="reference">Reference&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://sst.dev/chapters/zh/what-is-serverless.html">https://sst.dev/chapters/zh/what-is-serverless.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.cloudflare.com/introducing-d1/">https://blog.cloudflare.com/introducing-d1/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://aws.amazon.com/free/">https://aws.amazon.com/free/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://azure.microsoft.com/en-us/pricing/free-services/">https://azure.microsoft.com/en-us/pricing/free-services/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.infoq.com/news/2022/12/aws-lambda-snapstart-accelerate/">https://www.infoq.com/news/2022/12/aws-lambda-snapstart-accelerate/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/wundergraph/wunderbase">https://github.com/wundergraph/wunderbase&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.sqlite.org/serverless.html">https://www.sqlite.org/serverless.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/neondatabase/neon">https://github.com/neondatabase/neon&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>如何零成本给博客集成 umami 数据统计分析功能</title><link>https://guangzhengli.com/blog/zh/how-to-integrate-umami-for-free-to-blog-site/</link><pubDate>Sun, 14 Aug 2022 21:34:36 +0800</pubDate><author>iguangzhengli@gmail.com (Guangzheng Li)</author><guid>https://guangzhengli.com/blog/zh/how-to-integrate-umami-for-free-to-blog-site/</guid><description>&lt;p>本篇文章介绍如何零成本给博客或者网站集成 &lt;a href="https://umami.is/">umami&lt;/a> 统计功能。数据库用的是 &lt;a href="https://app.supabase.com/">supabase&lt;/a> 提供的有限额的 &lt;a href="https://supabase.com/docs/guides/database">postgres&lt;/a>，不过免费提供的 500M 对于 &lt;a href="https://umami.is/">umami&lt;/a> 来讲已经足够了。&lt;/p>
&lt;p>托管 &lt;a href="https://umami.is/">umami&lt;/a> 服务用的是 &lt;a href="https://vercel.com/">vercel&lt;/a>。得益于现在的云厂商优秀的服务能力，你可以在 10 分钟内集成好 &lt;em>umami&lt;/em>。可以点击 &lt;a href="https://umami-ochre-nu.vercel.app/share/o3zAba1V/guangzhengli">数据统计看板&lt;/a> 查看最终效果。&lt;/p>
&lt;h2 id="创建数据库">创建数据库&lt;/h2>
&lt;p>数据库用的是 &lt;a href="https://app.supabase.com/">supabase&lt;/a> 提供的有限额的 &lt;a href="https://supabase.com/docs/guides/database">postgres&lt;/a> 数据库，创建一个 supabase 账号，新建一个项目，输入 Datebase password 即可创建数据库服务。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/WWmfTm.jpg" alt="WWmfTm">&lt;/p>
&lt;p>创建可能会话费几分钟时间，创建完成后只需要拿到 &lt;code>DATABASE_URL&lt;/code> 即可。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/hvpSuQ.jpg" alt="hvpSuQ">&lt;/p>
&lt;h2 id="托管-umami">托管 umami&lt;/h2>
&lt;p>托管 &lt;a href="https://umami.is/">umami&lt;/a> 服务用的是 &lt;a href="https://vercel.com/">vercel&lt;/a>。创建好数据库实例之后，可以通过 Vercel 一键部署 umami 服务了。访问 &lt;a href="https://umami.is/">umami 官方文档&lt;/a> 的 &lt;a href="https://umami.is/docs/running-on-vercel">Running on Vercel&lt;/a> 模块，有操作说明与一键部署脚本。&lt;/p>
&lt;p>首先我们登录 GitHub 账号， &lt;code>fork&lt;/code> umami (&lt;a href="https://github.com/umami-software/umami">https://github.com/umami-software/umami&lt;/a>) 项目。&lt;/p>
&lt;p>登录 &lt;a href="https://vercel.com/">vercel&lt;/a> ，创建一个的账号，建议使用 GitHub 账号注册登录，在 &lt;code>new project&lt;/code> 中选择 &lt;code>import&lt;/code> 你刚刚 &lt;code>fork&lt;/code> 的项目。&lt;/p>
&lt;p>之后填写环境变量，这里我们需要填写两个环境变量&lt;/p>
&lt;ul>
&lt;li>DATABASE_URL：在创建数据库中拿到的 DATABASE_URL&lt;/li>
&lt;li>TRACKER_SCRIPT_NAME： 这里默认的 &lt;code>tracker_script_name&lt;/code> 可能会导致部分 &lt;code>AdBlock&lt;/code> 拦截请求，损失一部分的访问数据，所以这里我填的是 &lt;code>hugo-ladder&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>最后在 Build 阶段， &lt;code>build command&lt;/code> 记得填写 &lt;code>yarn build &amp;amp;&amp;amp; yarn update-db&lt;/code>，这样的话会自动 migrate 数据库的表。无需自己手动导入。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/rtIZCn.jpg" alt="rtIZCn">&lt;/p>
&lt;p>当然如果你想自己导入的话，也可以直接从这里 &lt;a href="https://github.com/umami-software/umami/blob/master/sql/schema.postgresql.sql">https://github.com/umami-software/umami/blob/master/sql/schema.postgresql.sql&lt;/a> 获取需要的表。&lt;/p>
&lt;h2 id="配置-umami">配置 umami&lt;/h2>
&lt;p>在 vercel 部署完成 umami 后会得到一个 &lt;code>&amp;lt;deploy-id&amp;gt;.vercel.app&lt;/code> ，我们访问它，默认的账号密码是 &lt;strong>admin&lt;/strong> 和 &lt;strong>umami&lt;/strong>。&lt;/p>
&lt;p>完成基础帐号配置后，点击侧边栏网站 Tab，点击添加网站。填写网站基本信息，可以勾选 &lt;code>enable share URL&lt;/code>，这样任何人都可以访问这个数据看板。&lt;/p>
&lt;p>我们拿到对应的 &lt;code>data-website-id&lt;/code> 和 &lt;code>src&lt;/code> ，填入主题配置中的 &lt;code>params.analytics.umami.website_id&lt;/code> 和 &lt;code>params.analytics.umami.url&lt;/code> 即可。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/YLRdbm.jpg" alt="YLRdbm">&lt;/p>
&lt;p>最终，我们可以得到本站数据统计看板的功能🎉🎉🎉&lt;/p></description></item><item><title>如何 30 分钟搭建一套完整独立博客</title><link>https://guangzhengli.com/blog/zh/how-to-create-your-blog-for-free-by-hugo-ladder-in-30min/</link><pubDate>Sun, 14 Aug 2022 16:47:12 +0800</pubDate><author>iguangzhengli@gmail.com (Guangzheng Li)</author><guid>https://guangzhengli.com/blog/zh/how-to-create-your-blog-for-free-by-hugo-ladder-in-30min/</guid><description>&lt;p>本文是关于如何搭建免费的独立博客系列的第二篇，包括如何使用本博客主题 &lt;code>hugo-ladder&lt;/code>，如何集成评论和统计功能等。如果后续打算使用该主题来搭建和运营博客，建议跟随本篇文章来搭建。&lt;/p>
&lt;h2 id="hugo">Hugo&lt;/h2>
&lt;h3 id="技术选型">技术选型&lt;/h3>
&lt;p>今天的大多数网站分为两类&amp;ndash;动态网站和静态网站。动态网站是基于服务器的，它的内容是变化的，可以根据用户返回不同的内容。例如根据不同用户的喜好进行推荐，根据地区进行内容语言区分。页面依靠内容管理系统（CMS）或数据库进行渲染，并可以随着需求的增长而不断增加复杂性。而缺点的话也很明显，首先你需要一笔不菲的服务器费用来支持带宽和并发，如果服务是面向全球的，还需要考虑多地部署来提升访问速度。&lt;/p>
&lt;p>还有一种就是我们选择的静态网站，使用 static site generators (SSG) 技术，会向所有用户显示相同的内容。使用服务器端的渲染来提供HTML、CSS和Javascript文件。静态网站的优势包括速度、安全和SEO。还易于维护，并具有高度可扩展性。由于静态网站生成器（SSG）在CDN上存储一个已经编译好的页面，它们的加载速度要快得多。&lt;/p>
&lt;p>我们可以选择免费托管到 CDN 或者平台 &lt;a href="https://netlify.com/">Netlify&lt;/a>、&lt;a href="https://www.heroku.com/">Heroku&lt;/a>、&lt;a href="https://www.godaddy.com/">GoDaddy&lt;/a>、&lt;a href="https://www.dreamhost.com/">DreamHost&lt;/a>、&lt;a href="https://pages.github.com/">GitHub Pages&lt;/a>、&lt;a href="https://about.gitlab.com/features/pages/">GitLab Pages&lt;/a>、&lt;a href="https://surge.sh/">Surge&lt;/a>、&lt;a href="https://firebase.google.com/docs/hosting/">Firebase&lt;/a>、&lt;a href="https://cloud.google.com/storage/">Google Cloud Storage&lt;/a>、&lt;a href="https://aws.amazon.com/s3/">Amazon S3&lt;/a>、&lt;a href="https://www.rackspace.com/cloud/files">Rackspace&lt;/a>、&lt;a href="https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website">Azure&lt;/a>和 &lt;a href="https://aws.amazon.com/cloudfront/">CloudFront&lt;/a> 上。&lt;/p>
&lt;p>对于开发者来讲，托管到 &lt;a href="https://pages.github.com/">GitHub Pages&lt;/a> 是最熟悉的方案，我们本篇文章也是基于此方案展开的教程。不过 &lt;a href="https://pages.github.com/">GitHub Pages&lt;/a> 对于部分地区的访问速度来讲并不友好，可以考虑使用其它自带 CDN 的免费平台来部署，例如本站使用的 &lt;a href="https://pages.cloudflare.com/">Cloudflare Pages&lt;/a>。&lt;/p>
&lt;p>在 static site generators (SSG) 方案中，有几种常见的方案，&lt;a href="https://hexo.io/">Hexo&lt;/a>, &lt;a href="https://jekyllrb.com/">Jekyll&lt;/a>, &lt;a href="https://gohugo.io/">Hugo&lt;/a> 和 &lt;a href="https://nextjs.org/">Next.js&lt;/a>。&lt;/p>
&lt;p>其中 &lt;a href="https://hexo.io/">Hexo&lt;/a> 的生态是最丰富和完善的，在 GitHub 中能找到最多的主题适配、最完善的第三方支持。但是考虑到我后续会自己开发定制化的主题和功能，去翻阅了下 &lt;a href="https://hexo.io/">Hexo&lt;/a> 的官方文档，结果 &lt;a href="https://hexo.io/">Hexo&lt;/a> 的文档不能说是事无巨细吧，只能说是等于没有。&lt;a href="https://nextjs.org/">Next.js&lt;/a> 是非常符合未来的一门技术，也是我比较心动的方案，但是后续发现 &lt;a href="https://nextjs.org/">Next.js&lt;/a> 在开发博客的生态上目前还不够完善。&lt;/p>
&lt;p>所以在对比了几项技术的优缺点后，我最终采用了Hugo。&lt;a href="https://gohugo.io/">Hugo&lt;/a> 是基于 &lt;code>golang&lt;/code> 编写的快速、现代的静态网站生成器。在 benchmark 测试中可以一秒渲染 5000 篇文章，也具备完善的生态。&lt;/p>
&lt;h3 id="安装">安装&lt;/h3>
&lt;p>安装 &lt;code>Hugo&lt;/code> 可以按照官方的文档一步一步安装 &lt;a href="https://gohugo.io/getting-started/installing">hugo install&lt;/a>。也可以按照下面命令快速安装。&lt;/p>
&lt;div class="tabs tabs-left">
&lt;style>
.tabs input#tab-0-0:checked ~ .tab-content-0-0 {
display: block;
}
&lt;/style>
&lt;input type="radio" class="tab-input" name="tab-select-0" id="tab-0-0" checked/>
&lt;label for="tab-0-0" class="tab-label">MacOS / Linux&lt;/label>
&lt;div class="tab-content tab-content-0-0">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>brew install hugo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;style>
.tabs input#tab-0-1:checked ~ .tab-content-0-1 {
display: block;
}
&lt;/style>
&lt;input type="radio" class="tab-input" name="tab-select-0" id="tab-0-1" />
&lt;label for="tab-0-1" class="tab-label">Window&lt;/label>
&lt;div class="tab-content tab-content-0-1">
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>choco install hugo -confirm
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;/div>
&lt;p>可以通过 &lt;code>hugo version&lt;/code> 来确保安装成功。&lt;/p>
&lt;h2 id="ladder">Ladder&lt;/h2>
&lt;p>本博客的主题名为 &lt;code>ladder&lt;/code>，中文即阶梯的含义，读书为输入，写作为输出，都是获取知识的阶梯。&lt;/p>
&lt;p>Ladder 主题的仓库地址是：&lt;a href="https://github.com/guangzhengli/hugo-theme-ladder">https://github.com/guangzhengli/hugo-theme-ladder&lt;/a>&lt;/p>
&lt;p>为大家准备好的一个已经配置好的仓库地址是： &lt;a href="https://github.com/guangzhengli/hugo-ladder-exampleSite">https://github.com/guangzhengli/hugo-ladder-exampleSite&lt;/a>&lt;/p>
&lt;p>如果你打算熟悉 &lt;code>hugo&lt;/code> 命令或者后续持续开发的话 ，可以从 &lt;a href="#%E9%85%8D%E7%BD%AE%E5%88%9D%E5%A7%8B%E5%8C%96">#配置初始化&lt;/a>一步一步来。&lt;/p>
&lt;p>如果你之前没有使用过 &lt;code>hugo&lt;/code> 或者是打算迁移博客的话，可以直接输入克隆已经初始化好的，在浏览器打开 &lt;code>http://localhost:1313/&lt;/code>。&lt;strong>并且可以直接跳转到 &lt;a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE">#自定义配置&lt;/a>。无需做初始化操作&lt;/strong>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>git clone https://github.com/guangzhengli/hugo-ladder-exampleSite.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hugo server -D
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="配置初始化">配置初始化&lt;/h3>
&lt;p>Hugo 提供了一个 &lt;code>new&lt;/code> 命令来创建一个新的网站:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>hugo new site my_website
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd my_website
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>git init
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git submodule add https://github.com/guangzhengli/hugo-theme-ladder themes/hugo-theme-ladder
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为个人偏爱 &lt;code>yml&lt;/code> 的阅读习惯，所以本文使用 &lt;code>yml&lt;/code> 而非默认的 &lt;code>toml&lt;/code> 文件类型来配置，大家可以根据偏好到 &lt;a href="https://transform.tools/yaml-to-toml">transform.tool&lt;/a> 进行转换。&lt;/p>
&lt;p>下面是本主题完整的 &lt;code>config.yml&lt;/code> 文件，大家可以删除根目录下默认的 &lt;code>config.toml&lt;/code> 文件，新建一个 &lt;code>config.yml&lt;/code> 文件代替。&lt;/p>
&lt;p>
&lt;details class="toggle">
&lt;summary markdown="span">点击查看完整的 &lt;code>config.yml&lt;/code> 文件&lt;/summary>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">baseURL&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;https://hugo-ladder.pages.dev&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">title&lt;/span>: &lt;span style="color:#ae81ff">LADDER&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">theme&lt;/span>: &lt;span style="color:#ae81ff">hugo-theme-ladder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">license&lt;/span>: &lt;span style="color:#ae81ff">MIT&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">licenselink&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;https://github.com/guangzhengli/hugo-theme-ladder/blob/master/LICENSE&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;A fast, clean Hugo theme&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">homepage&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;https://hugo-ladder.pages.dev&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">defaultContentLanguage&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;en&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">googleAnalytics&lt;/span>: &lt;span style="color:#ae81ff">G-xxx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">paginate&lt;/span>: &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">params&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">brand&lt;/span>: &lt;span style="color:#ae81ff">HOME&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">avatarURL&lt;/span>: &lt;span style="color:#ae81ff">/images/avatar.png&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">author&lt;/span>: &lt;span style="color:#ae81ff">Hugo Ladder&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">authorDescription&lt;/span>: &lt;span style="color:#ae81ff">A clean, fast hugo theme focused on Reading&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">info&lt;/span>: &lt;span style="color:#ae81ff">Build a free and beautiful blog site to record your thoughts and increase your influence&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">favicon&lt;/span>: &lt;span style="color:#ae81ff">/images/avatar.png&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">options&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">showDarkMode&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enableImgZooming&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enableMultiLang&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">darkModeTheme&lt;/span>: &lt;span style="color:#ae81ff">data-dark-mode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#darkModeTheme: icy-dark-mode&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">comments&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">giscus&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enable&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">repo&lt;/span>: &lt;span style="color:#ae81ff">username/repo&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">repo_id&lt;/span>: &lt;span style="color:#ae81ff">xxx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">category&lt;/span>: &lt;span style="color:#ae81ff">Announcements&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">category_id&lt;/span>: &lt;span style="color:#ae81ff">xxx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">mapping&lt;/span>: &lt;span style="color:#ae81ff">pathname&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">position&lt;/span>: &lt;span style="color:#ae81ff">top&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">lang&lt;/span>: &lt;span style="color:#ae81ff">en&lt;/span> &lt;span style="color:#75715e"># pick a language from https://github.com/giscus/giscus/tree/main/locales&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">utteranc&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enable&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">repo&lt;/span>: &lt;span style="color:#ae81ff">username/xxx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">issueTerm&lt;/span>: &lt;span style="color:#ae81ff">pathname&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">analytics&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">google&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">SiteVerificationTag&lt;/span>: &lt;span style="color:#ae81ff">xxx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">umami&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enable&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">website_id&lt;/span>: &lt;span style="color:#ae81ff">xxx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#ae81ff">https://xxx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">guestbook&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">title&lt;/span>: &lt;span style="color:#ae81ff">Guestbook&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#ae81ff">Leave a comment below. It could be anything –- question, appreciation, information, or even humor.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">social&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">GitHub&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">pre&lt;/span>: &amp;gt;-&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;svg xmlns=&amp;#34;http://www.w3.org/2000/svg&amp;#34; width=&amp;#34;20&amp;#34; height=&amp;#34;20&amp;#34; viewBox=&amp;#34;0 0 24 24&amp;#34; fill=&amp;#34;none&amp;#34; stroke=&amp;#34;currentColor&amp;#34; stroke-width=&amp;#34;2&amp;#34; stroke-linecap=&amp;#34;round&amp;#34; stroke-linejoin=&amp;#34;round&amp;#34; class=&amp;#34;feather feather-github&amp;#34;&amp;gt;&amp;lt;path d=&amp;#34;M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22&amp;#34;&amp;gt;&amp;lt;/path&amp;gt;&amp;lt;/svg&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;https://github.com/username/xxx&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Dashboard&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">pre&lt;/span>: &amp;gt;-&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;svg xmlns=&amp;#34;http://www.w3.org/2000/svg&amp;#34; width=&amp;#34;20&amp;#34; height=&amp;#34;20&amp;#34; viewBox=&amp;#34;0 0 24 24&amp;#34; fill=&amp;#34;none&amp;#34; stroke=&amp;#34;currentColor&amp;#34; stroke-width=&amp;#34;2&amp;#34; stroke-linecap=&amp;#34;round&amp;#34; stroke-linejoin=&amp;#34;round&amp;#34; class=&amp;#34;feather feather-box&amp;#34;&amp;gt;&amp;lt;path d=&amp;#34;M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z&amp;#34;&amp;gt;&amp;lt;/path&amp;gt;&amp;lt;polyline points=&amp;#34;3.27 6.96 12 12.01 20.73 6.96&amp;#34;&amp;gt;&amp;lt;/polyline&amp;gt;&amp;lt;line x1=&amp;#34;12&amp;#34; y1=&amp;#34;22.08&amp;#34; x2=&amp;#34;12&amp;#34; y2=&amp;#34;12&amp;#34;&amp;gt;&amp;lt;/line&amp;gt;&amp;lt;/svg&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;https://xxx&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">languages&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">en&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">languageName&lt;/span>: &lt;span style="color:#ae81ff">EN&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">menu&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">main&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Blog&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#ae81ff">/blog&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Tags&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#ae81ff">/tags&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Archive&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#ae81ff">/archives&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Guestbook&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#ae81ff">/guestbook&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Dashboard&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#ae81ff">https://xxx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">zh&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">languageName&lt;/span>: &lt;span style="color:#ae81ff">中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">author&lt;/span>: &lt;span style="color:#ae81ff">Ladder 主题&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">authorDescription&lt;/span>: &lt;span style="color:#ae81ff">一个美观，快速并且专注于阅读的主题&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">info&lt;/span>: &lt;span style="color:#ae81ff">帮助开发者构建一个免费并且漂亮的博客网站，记录自己的思考并且提高自己的影响力&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">guestbook&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">title&lt;/span>: &lt;span style="color:#ae81ff">留言板&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#ae81ff">您的评论，会让该网站更精彩！&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">menu&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">main&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">文章&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#ae81ff">/blog&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">分类&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#ae81ff">/tags&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">历史文章&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#ae81ff">/archives&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">留言板&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#ae81ff">/guestbook&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">网站统计&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#ae81ff">https://xxx&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">taxonomies&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">series&lt;/span>: &lt;span style="color:#ae81ff">series&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">tag&lt;/span>: &lt;span style="color:#ae81ff">tags&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/details>
&lt;/p>
&lt;h3 id="启动博客">启动博客&lt;/h3>
&lt;p>首先我们找到根目录下 &lt;code>archetypes&lt;/code> 文件夹中的 &lt;code>default.md&lt;/code> 文件，用下面的文件替代其中内容。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-markdown" data-lang="markdown">&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>title:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>date: {{ .Date }}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tags: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>series: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>featured: true
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Here is summary.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&amp;lt;!--more--&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>here is your content.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>复制 &lt;code>themes/ladder/exampleSite/content&lt;/code> 里面的内容到自己的根目录的 &lt;code>content&lt;/code> 下面。&lt;/p>
&lt;p>输入命令创建一篇名为 &lt;code>my-first-blog&lt;/code> 新的博客。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>hugo new blog/my-first-blog.md
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建后可以使用 &lt;code>hugo server -D&lt;/code> 来启动博客，并且在浏览器打开 &lt;code>http://localhost:1313/&lt;/code>，即可看到你的博客网站。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>hugo server -D
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="自定义配置">自定义配置&lt;/h2>
&lt;h3 id="多语言支持">多语言支持&lt;/h3>
&lt;p>首先我们需要确定我们博客默认使用的语言是哪种？是否需要多语言的支持？例如我们默认语言使用英文，那么 &lt;code>defaultContentLanguage&lt;/code> 即使用默认的 &lt;code>en&lt;/code>，假如默认使用中文就是 &lt;code>zh&lt;/code>。&lt;/p>
&lt;p>除此之外，如果不需要多语言的支持，先将 &lt;code>params.options.enableMultiLang&lt;/code> 设置为 &lt;code>false&lt;/code>, 删除配置文件 &lt;code>languages&lt;/code> 配置下其它语言的配置即可。&lt;/p>
&lt;p>上面的文件展示的是本博客使用的配置，多语言配置中默认语言是英文，可以切换成中文。&lt;/p>
&lt;h3 id="修改基本信息">修改基本信息&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">baseURL&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;https://hugo-ladder.pages.dev&amp;#39;&lt;/span> &lt;span style="color:#75715e">#修改为你的 https://username.github.io&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">homepage&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;https://hugo-ladder.pages.dev&amp;#39;&lt;/span> &lt;span style="color:#75715e">#修改为你的 https://username.github.io&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">params&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">brand&lt;/span>: &lt;span style="color:#ae81ff">HOME&lt;/span> &lt;span style="color:#75715e"># 修改默认的为自己网站的标志&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">avatarURL&lt;/span>: &lt;span style="color:#ae81ff">/images/avatar.png&lt;/span> &lt;span style="color:#75715e">#网站主页的照片信息，你可以在根目录 /static/images/ 里面替换成自己的照片&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">author&lt;/span>: &lt;span style="color:#ae81ff">Hugo Ladder&lt;/span> &lt;span style="color:#75715e"># 修改你自己的名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">authorDescription&lt;/span>: &lt;span style="color:#75715e"># 修改对你自己的描述&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">info&lt;/span>: &lt;span style="color:#75715e"># 修改对你自己网站描述&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">favicon&lt;/span>: &lt;span style="color:#ae81ff">/images/avatar.png&lt;/span> &lt;span style="color:#75715e">#网站的 icon，你可以在根目录 /static/images/ 里面替换成自己的照片&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">options&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">showDarkMode&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span> &lt;span style="color:#75715e"># 是否支持黑暗模式&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">languages&lt;/span>: &lt;span style="color:#75715e"># 如果你启用多语言，下面是中文展示&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">zh&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">languageName&lt;/span>: &lt;span style="color:#ae81ff">中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">author&lt;/span>: &lt;span style="color:#ae81ff">Ladder 主题&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">authorDescription&lt;/span>: &lt;span style="color:#ae81ff">一个美观，快速并且专注于阅读的主题&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">info&lt;/span>: &lt;span style="color:#ae81ff">帮助开发者构建一个免费并且漂亮的博客网站，记录自己的思考并且提高自己的影响力&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你可以一边修改一边通过浏览器打开 &lt;code>http://localhost:1313/&lt;/code> 实时观看效果。&lt;/p>
&lt;h3 id="导航栏">导航栏&lt;/h3>
&lt;p>目前本博客支持 4 种默认的页面，即博客列表，标签分类，历史文章和留言板，&lt;/p>
&lt;p>可以通过修改 &lt;code>menu.main&lt;/code> 来调整 &lt;code>名称&lt;/code> ，如果要添加新的页面或者修改 &lt;code>URL&lt;/code> 的话，记得在根目录的 &lt;code>content&lt;/code> 下面添加对应的 &lt;code>markdown&lt;/code> 文件。&lt;/p>
&lt;h3 id="黑暗模式">黑暗模式&lt;/h3>
&lt;p>本主题目前提供两种黑暗模式，一种是默认的 &lt;code>data-dark-mode&lt;/code> 模式，还有一种是 &lt;code>icy-dark-mode&lt;/code> 模式，可以通过修改 &lt;code>params.darkModeTheme&lt;/code> 的参数进行替换。大家可以自行探索，也欢迎贡献新的模式。&lt;/p>
&lt;h3 id="社交图标">社交图标&lt;/h3>
&lt;p>可以通过修改配置文件添加新的图标， &lt;code>params.social&lt;/code> 字段标明 &lt;code>名称&lt;/code>，&lt;code>图标&lt;/code>，&lt;code>自定义地址&lt;/code>，图标可以在这个网站找到 &lt;a href="https://feathericons.com/">feathericons.com&lt;/a>。&lt;/p>
&lt;h2 id="内容管理">内容管理&lt;/h2>
&lt;h3 id="文章管理">文章管理&lt;/h3>
&lt;p>每一次写文章建议填写的配置（也可以不填），文章开头有这个几个字段，分别代表着&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-markdown" data-lang="markdown">&lt;span style="display:flex;">&lt;span>title:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>date: {{ .Date }}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tags: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>series: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>featured: true
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>title&lt;/code> 文章题目&lt;/li>
&lt;li>&lt;code>date&lt;/code> 发布日期&lt;/li>
&lt;li>&lt;code>tags&lt;/code> 标签分类&lt;/li>
&lt;li>&lt;code>series&lt;/code> 系列文章，会在下方推荐阅读中推荐同系列文章&lt;/li>
&lt;li>&lt;code>featured&lt;/code> 是否在主页面中展示，&lt;code>true&lt;/code> or &lt;code>false&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="富文本功能">富文本功能&lt;/h3>
&lt;p>目前博客默认集成 &lt;code>Toggle&lt;/code>和 &lt;code>Tab group&lt;/code> 两种富文本， &lt;code>Toggle&lt;/code> 的效果例如 &lt;a href="#%E9%85%8D%E7%BD%AE%E5%88%9D%E5%A7%8B%E5%8C%96">#配置初始化&lt;/a> 中可以隐藏代码或者文本， &lt;code>Tab group&lt;/code> 的效果例如在 &lt;a href="#%E5%AE%89%E8%A3%85">#安装Hugo&lt;/a> 中可以切换标签来写教程或文本。&lt;/p>
&lt;p>除此之外，还有集成 &lt;code>youtube&lt;/code> &lt;code>twitter &lt;/code> 和 &lt;code>站点页面跳转&lt;/code> 等富文本功能。详细可以查看 &lt;a href="https://hugo-ladder.pages.dev/blog/tag-plugins/">rich content&lt;/a>。&lt;/p>
&lt;p>我还新建了一个仓库 &lt;a href="https://github.com/guangzhengli/awesome-hugo-shortcodes">https://github.com/guangzhengli/awesome-hugo-shortcodes&lt;/a> ，用来收集 &lt;code>hugo shortcodes&lt;/code> ，大家可以去看看有没有自己需要的，可以自行添加。&lt;/p>
&lt;h2 id="留言板和评论功能集成">留言板和评论功能集成&lt;/h2>
&lt;p>本主题留言板和评论功能支持两种集成，一种是基于 &lt;a href="https://docs.github.com/en/issues">GitHub Issues&lt;/a> 的 &lt;a href="https://utteranc.es/">utteranc&lt;/a>，还有一种是基于&lt;a href="https://docs.github.com/en/discussions">GitHub Discussions&lt;/a> 的 &lt;a href="https://giscus.app/">giscus&lt;/a>。&lt;/p>
&lt;p>这里推荐大家使用基于&lt;a href="https://docs.github.com/en/discussions">GitHub Discussions&lt;/a> 的 &lt;a href="https://giscus.app/">giscus&lt;/a>，毕竟 &lt;code>Issues&lt;/code> 是比较严肃的功能， &lt;a href="https://giscus.app/">giscus&lt;/a> 的页面也比较美观，还可以在同一话题下持续回复。&lt;/p>
&lt;p>集成这两者的步骤都十分简单，只需要跟随 &lt;a href="https://utteranc.es/">utteranc&lt;/a> 和 &lt;a href="https://giscus.app/">giscus&lt;/a> 官方教程走到最后，生成对应的配置值，填入 &lt;code>params.comments&lt;/code> 里面对应的 &lt;code>giscus&lt;/code> &lt;code>utteranc&lt;/code> 即可，需要将另外的一个的 &lt;code>enable&lt;/code> 设置成 &lt;code>false&lt;/code>。&lt;/p>
&lt;h2 id="网站数据统计功能">网站数据统计功能&lt;/h2>
&lt;p>主题可以集成 &lt;a href="https://analytics.google.com/analytics/web/">Google analytics&lt;/a> 和 &lt;a href="https://umami.is/">umami&lt;/a> 两种网站数据统计能力。&lt;/p>
&lt;p>&lt;a href="https://analytics.google.com/analytics/web/">Google analytics&lt;/a> 可以通过官方文档得到对应 &lt;code>G-xxx&lt;/code> 开头的 &lt;code>MEASUREMENT ID&lt;/code> ，填入配置文件中的 &lt;code>googleAnalytics&lt;/code> 即可。&lt;/p>
&lt;p>&lt;a href="https://analytics.google.com/analytics/web/">Google analytics&lt;/a> 的集成简单和免费，不过缺点是无法做到隐私保护（对应数据会提供给 Google），页面也是比较笨重和缓慢。&lt;/p>
&lt;p>所以大家如果有需求可以自己搭建 &lt;a href="https://umami.is/">umami&lt;/a> 来做数据统计，相关过程和步骤我放到另外的一篇博客 &lt;a href="https://guangzhengli.com/blog/zh/how-to-integrate-umami-for-free-to-blog-site/">如何免费搭建的 umami&lt;/a>。&lt;/p>
&lt;h2 id="seo">SEO&lt;/h2>
&lt;p>&lt;code>SEO&lt;/code> 目前主题已经做了对应的优化，包括完善的 &lt;code>meta&lt;/code> 标签信息等。 除此之外，默认支持 &lt;a href="https://search.google.com/search-console">Google Search Console&lt;/a>，可以根据官方相关文档生成对应的 &lt;code>google-site-verification&lt;/code> ，填入对应的 &lt;code>params.analytics.google.SiteVerificationTag&lt;/code>。&lt;/p>
&lt;h2 id="部署">部署&lt;/h2>
&lt;p>关于部署也有多种方式，可以选择托管到 CDN 或者平台 &lt;a href="https://netlify.com/">Netlify&lt;/a>、&lt;a href="https://www.heroku.com/">Heroku&lt;/a>、&lt;a href="https://www.godaddy.com/">GoDaddy&lt;/a>、&lt;a href="https://www.dreamhost.com/">DreamHost&lt;/a>、&lt;a href="https://pages.github.com/">GitHub Pages&lt;/a>、&lt;a href="https://about.gitlab.com/features/pages/">GitLab Pages&lt;/a>、&lt;a href="https://surge.sh/">Surge&lt;/a>、&lt;a href="https://firebase.google.com/docs/hosting/">Firebase&lt;/a>、&lt;a href="https://cloud.google.com/storage/">Google Cloud Storage&lt;/a>、&lt;a href="https://aws.amazon.com/s3/">Amazon S3&lt;/a>、&lt;a href="https://www.rackspace.com/cloud/files">Rackspace&lt;/a>、&lt;a href="https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website">Azure&lt;/a>和 &lt;a href="https://aws.amazon.com/cloudfront/">CloudFront&lt;/a> 。&lt;/p>
&lt;p>本文选择大家比较通用的 &lt;a href="https://pages.github.com/">GitHub Pages&lt;/a> 来作为教程。&lt;/p>
&lt;h3 id="创建-githubhttpsgithubcom-账号">创建 &lt;a href="https://github.com/">GitHub&lt;/a> 账号&lt;/h3>
&lt;p>在搭建自己的博客前，我们需要先注册一个 &lt;a href="https://github.com/">GitHub&lt;/a> 账号，这个账号的账户名非常重要，它是后面我们博客的域名地址。&lt;/p>
&lt;p>例如我们创建的账号名称是 guangzhengli，那么我们最终的博客地址就是 &lt;a href="https://guangzhengli.github.io">https://guangzhengli.github.io&lt;/a>。&lt;/p>
&lt;h3 id="创建-github-pages-仓库">创建 GitHub Pages 仓库&lt;/h3>
&lt;p>完整的教程可以查看 &lt;a href="https://pages.github.com/">官方教程&lt;/a>，简单来讲就是 &lt;a href="https://github.com/new">创建一个新的 repository&lt;/a>，名字为 &lt;code>username.github.io&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/Xu5ikP.jpg" alt="Xu5ikP">&lt;/p>
&lt;h3 id="actions">Actions&lt;/h3>
&lt;p>&lt;code>Actions&lt;/code> 方式用两种，一种是直接推送到 &lt;a href="https://pages.github.com/">GitHub Pages&lt;/a> ，还有一种是在 &lt;code>gh-pages&lt;/code> 分支上生成静态页面代码的方式。代码都在 &lt;a href="https://github.com/guangzhengli/hugo-ladder-exampleSite/tree/master/.github/workflows">https://github.com/guangzhengli/hugo-ladder-exampleSite/tree/master/.github/workflows&lt;/a> 这里。&lt;/p>
&lt;p>如果你不是选择的直接克隆已经配置好的仓库： &lt;a href="https://github.com/guangzhengli/hugo-ladder-exampleSite">https://github.com/guangzhengli/hugo-ladder-exampleSite&lt;/a>。需要创建新的文件夹 &lt;code>.github/workflows&lt;/code> ，添加新的文件 &lt;code>gh-pages.yml&lt;/code> 文件。&lt;/p>
&lt;p>{{ &lt;!-- raw HTML omitted -->}}&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">generate github pages to gh-pages branch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">on&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">push&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">branches&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">main&lt;/span> &lt;span style="color:#75715e">## Set a branch name to trigger deployment&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">jobs&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">deploy&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">runs-on&lt;/span>: &lt;span style="color:#ae81ff">ubuntu-20.04&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">steps&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">actions/checkout@v2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">with&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">submodules&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span> &lt;span style="color:#75715e"># Fetch Hugo themes (true OR recursive)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fetch-depth&lt;/span>: &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#75715e"># Fetch all history for .GitInfo and .Lastmod&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Setup Hugo&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">peaceiris/actions-hugo@v2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">with&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">hugo-version&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;latest&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">extended&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Build&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">run&lt;/span>: &lt;span style="color:#ae81ff">hugo --minify&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Deploy&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">uses&lt;/span>: &lt;span style="color:#ae81ff">peaceiris/actions-gh-pages@v3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># If you&amp;#39;re changing the branch from main, &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># also change the `main` in `refs/heads/main` &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># below accordingly.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">if&lt;/span>: &lt;span style="color:#ae81ff">github.ref == &amp;#39;refs/heads/main&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">with&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">github_token&lt;/span>: &lt;span style="color:#ae81ff">${{ secrets.GITHUB_TOKEN }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">publish_dir&lt;/span>: &lt;span style="color:#ae81ff">./public&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>{{ &lt;!-- raw HTML omitted --> }}&lt;/p>
&lt;h3 id="部署-github-pages">部署 GitHub Pages&lt;/h3>
&lt;p>在你项目的根目录下输入以下命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>git remote add origin https://github.com/username/username.github.io.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git add .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git commit -m &lt;span style="color:#e6db74">&amp;#34;feat: init blog site&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git push origin main
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>确保我们推送成功后，我们会在 &lt;code>Actions&lt;/code> 中自动的将代码 build 成 GitHub Pages 需要的文件，可以到这个地址检查 &lt;code>workflow&lt;/code> 是否成功运行。注意将地址中 &lt;code>username&lt;/code> 替换成自己的账号名称。&lt;code>https://github.com/username/username.github.io/actions&lt;/code>。&lt;/p>
&lt;p>如果 &lt;code>Actions&lt;/code> 运行成功的话，我们会有一个新的分支叫做 &lt;code>gh-pages&lt;/code>。这时候我们去仓库的设置中心 &lt;code>Settings&lt;/code> ，选择 &lt;code>Pages&lt;/code> ，之后将 &lt;code>Build and deployment&lt;/code> -&amp;gt; &lt;code>Source&lt;/code> 选择 &lt;code>Deploy from a branch&lt;/code>。后面的 &lt;code>Branch&lt;/code> 选择 &lt;code>gh-pages&lt;/code> 即可配置成功。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/cuQE65.jpg" alt="cuQE65">&lt;/p>
&lt;p>这个时候，选择上方的 &lt;code>Visit site&lt;/code> 或者手动输入 &lt;code>https://username.github.io&lt;/code> 即可访问成功！ 🎉🎉🎉&lt;/p>
&lt;p>如果部署时，有任何问题，可以在下方留言。&lt;/p></description></item><item><title>如何 10 分钟快速搭建你自己的独立博客</title><link>https://guangzhengli.com/blog/zh/how-to-create-your-blog-for-free-in-10min/</link><pubDate>Mon, 01 Aug 2022 00:00:00 +0000</pubDate><author>iguangzhengli@gmail.com (Guangzheng Li)</author><guid>https://guangzhengli.com/blog/zh/how-to-create-your-blog-for-free-in-10min/</guid><description>&lt;p>本文是如何搭建免费的独立博客系列的第一篇，也将教大家如何快速的使用 &lt;a href="https://pages.github.com/">GitHub Pages&lt;/a> 的功能来搭建属于自己的博客。&lt;/p>
&lt;p>本篇文章属于快速入门版，可以帮助大家快速搭建和观察效果。如果是了解更多关于 &lt;a href="https://github.com/guangzhengli/hugo-theme-ladder">hugo-ladder&lt;/a> 的内容，建议跟随这篇文章来搭建 &lt;a href="https://guangzhengli.com/blog/zh/how-to-create-your-blog-for-free-by-hugo-ladder-in-30min/">如何 30 分钟搭建一套完整独立博客&lt;/a>。&lt;/p>
&lt;h2 id="准备工作">准备工作&lt;/h2>
&lt;h3 id="创建-githubhttpsgithubcom-账号">创建 &lt;a href="https://github.com/">GitHub&lt;/a> 账号&lt;/h3>
&lt;p>在搭建自己的博客前，我们需要先注册一个 &lt;a href="https://github.com/">GitHub&lt;/a> 账号，这个账号的账户名非常重要，它是后面我们博客的域名地址。&lt;/p>
&lt;p>例如我们创建的账号名称是 guangzhengli，那么我们最终的博客地址就是 &lt;a href="https://guangzhengli.github.io">https://guangzhengli.github.io&lt;/a>。&lt;/p>
&lt;h3 id="创建-github-pages-仓库">创建 GitHub Pages 仓库&lt;/h3>
&lt;p>完整的教程可以查看 &lt;a href="https://pages.github.com/">官方教程&lt;/a>，简单来讲就是 &lt;a href="https://github.com/new">创建一个新的 repository&lt;/a>，名字为 &lt;code>username.github.io&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/Xu5ikP.jpg" alt="Xu5ikP">&lt;/p>
&lt;h2 id="搭建博客">搭建博客&lt;/h2>
&lt;p>我们可以选择直接克隆已经准备好的仓库 &lt;a href="https://github.com/guangzhengli/hugo-ladder-exampleSite">hugo-ladder-exampleSite&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>git clone https://github.com/guangzhengli/hugo-ladder-exampleSite.git
&lt;/code>&lt;/pre>&lt;p>在拉取完代码后，我们需要修改配置信息，文件在根目录的 &lt;code>config.yml&lt;/code> 文件中，我们需要将 Demo 的配置修改成自己。&lt;/p>
&lt;blockquote>
&lt;p>请注意，一定记得修改配置信息，特别是拉取博客后大家会像评论配置等，否则将会给后续使用改教程的人带来困扰，谢谢🙏。如果想搭建自己独立的评论系统，可以参考这篇文章来搭建 &lt;a href="https://guangzhengli.com/blog/zh/how-to-create-your-blog-for-free-by-hugo-ladder-in-30min/">如何 30 分钟搭建一套完整独立博客&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h3 id="修改博客配置">修改博客配置&lt;/h3>
&lt;p>根目录的 &lt;code>config.yml&lt;/code> 文件，使用编辑器打开，修改如下大致的一些配置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">baseURL&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;https://hugo-ladder.pages.dev&amp;#39;&lt;/span> &lt;span style="color:#75715e">#修改为你的 https://username.github.io&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">homepage&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;https://hugo-ladder.pages.dev&amp;#39;&lt;/span> &lt;span style="color:#75715e">#修改为你的 https://username.github.io&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">defaultContentLanguage&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;en&amp;#39;&lt;/span> &lt;span style="color:#75715e">#修改默认语言，例如改为 zh 即默认使用中文&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">params&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">brand&lt;/span>: &lt;span style="color:#ae81ff">HOME&lt;/span> &lt;span style="color:#75715e"># 修改默认的为自己网站的标志&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">avatarURL&lt;/span>: &lt;span style="color:#ae81ff">/images/avatar.png&lt;/span> &lt;span style="color:#75715e">#网站主页的照片信息，你可以在根目录 /static/images/ 里面替换成自己的照片&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">author&lt;/span>: &lt;span style="color:#ae81ff">Hugo Ladder&lt;/span> &lt;span style="color:#75715e"># 修改你自己的名字&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">authorDescription&lt;/span>: &lt;span style="color:#75715e"># 修改对你自己的描述&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">info&lt;/span>: &lt;span style="color:#75715e"># 修改对你自己网站描述&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">favicon&lt;/span>: &lt;span style="color:#ae81ff">/images/avatar.png&lt;/span> &lt;span style="color:#75715e">#网站的 icon，你可以在根目录 /static/images/ 里面替换成自己的照片&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">options&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">showDarkMode&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span> &lt;span style="color:#75715e"># 是否使用切换黑暗模式&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enableMultiLang&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span> &lt;span style="color:#75715e"># 是否展示多语言选择&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">languages&lt;/span>: &lt;span style="color:#75715e"># 如果你启用多语言，下面是中文展示&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">zh&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">languageName&lt;/span>: &lt;span style="color:#ae81ff">中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">author&lt;/span>: &lt;span style="color:#ae81ff">Ladder 主题&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">authorDescription&lt;/span>: &lt;span style="color:#ae81ff">一个美观，快速并且专注于阅读的主题&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">info&lt;/span>: &lt;span style="color:#ae81ff">帮助开发者构建一个免费并且漂亮的博客网站，记录自己的思考并且提高自己的影响力&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="注释评论相关功能">注释评论相关功能&lt;/h3>
&lt;p>准备好的仓库 &lt;a href="https://github.com/guangzhengli/hugo-ladder-exampleSite">hugo-ladder-exampleSite&lt;/a> 主要给大家快速搭建使用。如果大家都使用同一套评论配置的话，会给后续使用该教程的人带来一定的困扰，可以先将相关功能注释掉。如果想搭建自己独立的评论系统，可以参考这篇文章来搭建 &lt;a href="https://guangzhengli.com/blog/zh/how-to-create-your-blog-for-free-by-hugo-ladder-in-30min/">如何 30 分钟搭建一套完整独立博客&lt;/a>。&lt;/p>
&lt;p>修改方案如下所示&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">comments&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">giscus&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enable&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>改为如下所示&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yml" data-lang="yml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">comments&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">giscus&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enable&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="如何添加和修改自己的博客文章">如何添加和修改自己的博客文章&lt;/h2>
&lt;p>可以在根目录的 &lt;code>content/blog&lt;/code> 中找到该站点的 Demo 展示文章，可以选择新增一个 &lt;code>markdown&lt;/code> 文件添加自己想要表达的内容即可。&lt;/p>
&lt;p>目前在文章头部，需要添加上这几个标签来配置文章的展示：&lt;/p>
&lt;ul>
&lt;li>&lt;code>title&lt;/code>：文章标题。&lt;/li>
&lt;li>&lt;code>date&lt;/code>: 发布时间。&lt;/li>
&lt;li>&lt;code>tags&lt;/code>: 文章的标签，便于后续检索和查找类似文章。&lt;/li>
&lt;li>&lt;code>series&lt;/code>: 系列文章，可以为空，便于在文章末尾相关文章推荐使用。&lt;/li>
&lt;li>&lt;code>featured&lt;/code>: &lt;code>true&lt;/code> 或者 &lt;code>false&lt;/code>，是否在主页推荐中展示。&lt;/li>
&lt;/ul>
&lt;p>其次，可以通过添加 &lt;code>&amp;lt;!--more--&amp;gt;&lt;/code> 标签，标明哪些文字需要在博客的列表中外部展示用，哪些文字需要隐藏，如果不添加的话，会默认展示一定的字数。&lt;/p>
&lt;h2 id="部署代码">部署代码&lt;/h2>
&lt;h3 id="推送代码到自己的仓库">推送代码到自己的仓库&lt;/h3>
&lt;p>在第一步时，我们创建了名为 &lt;code>username.github.io&lt;/code> 的仓库地址，可以使用下面命令先将指向仓库 &lt;a href="https://github.com/guangzhengli/hugo-ladder-exampleSite">hugo-ladder-exampleSite&lt;/a> 的远程 URL 先去除，再添加自己的地址。注意将下面命令中 &lt;code>username&lt;/code> 替换成自己的账号名称。&lt;/p>
&lt;p>最后我们再推送我们的修改到自己的仓库。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>git remote remove origin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git remote add origin https://github.com/username/username.github.io.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git add .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git commit -m &lt;span style="color:#e6db74">&amp;#34;feat: init blog site&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git push origin main
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="部署-github-pages">部署 GitHub Pages&lt;/h3>
&lt;p>确保我们推送成功后，我们会在 &lt;code>Actions&lt;/code> 中自动的将代码 build 成 GitHub Pages 需要的文件，可以到这个地址检查 &lt;code>workflow&lt;/code> 是否成功运行。注意将地址中 &lt;code>username&lt;/code> 替换成自己的账号名称。&lt;code>https://github.com/username/username.github.io/actions&lt;/code>。&lt;/p>
&lt;p>如果 &lt;code>Actions&lt;/code> 运行成功的话，我们会有一个新的分支叫做 &lt;code>gh-pages&lt;/code>。这时候我们去仓库的设置中心 &lt;code>Settings&lt;/code> ，选择 &lt;code>Pages&lt;/code> ，之后将 &lt;code>Build and deployment&lt;/code> -&amp;gt; &lt;code>Source&lt;/code> 选择 &lt;code>Deploy from a branch&lt;/code>。后面的 &lt;code>Branch&lt;/code> 选择 &lt;code>gh-pages&lt;/code> 即可配置成功。&lt;/p>
&lt;p>&lt;img src="https://storage.guangzhengli.com/images/cuQE65.jpg" alt="cuQE65">&lt;/p>
&lt;p>这个时候，选择上方的 &lt;code>Visit site&lt;/code> 或者手动输入 &lt;code>https://username.github.io&lt;/code> 即可访问成功！ 🎉🎉🎉&lt;/p>
&lt;p>如果部署时，有任何问题，可以在下方留言。&lt;/p></description></item></channel></rss>